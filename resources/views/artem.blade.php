@extends('layouts.mainLayout')

@section('content')
<div class="test">
    Курс артема прыгина
    <ul>
        <li>сделать фак курсор</li>
        <li>
            http://www.phphighload.com/2012/05/http.html
            http://www.rusmedvedev.ru/articles/view?id=22
            https://ospanel.io/download/
            https://zametkinapolyah.ru/servera-i-protokoly/chto-takoe-http-server-apache-ustanovka-veb-servera-apache-2-4-na-windows-gde-skachat-apache-2-4-dlya-windows.html
            https://habr.com/ru/post/267721/
            https://www.jetbrains.com/toolbox/app/
            https://habr.com/ru/company/dataart/blog/272165/
            https://www.amiro.ru/blog/tech/how-was-php6-died
            https://habr.com/ru/post/280071/
            https://habr.com/ru/post/215117/
            https://zen.yandex.ru/media/vpautinu_com/dnsserver-chto-eto-kak-vkliuchit-i-pravilno-nastroit-5a9260d8dcaf8e630fc6c1e0
            https://1cloud.ru/blog/chto-takoe-dns
        </li>
        <li>ckeditor плагин</li>
        <li>MVC</li>
        <li>https://github.com/barryvdh/laravel-debugbar</li>
        <li>http://phpdebugbar.com/docs/</li>
        <li>composer и плагины надо знать супер полезно</li>
        <li>https://github.com/barryvdh/laravel-ide-helper</li>
        <li>Миграции - это инструмент, который позволяет создавать и изменять таблицы в базе данных</li>
        <li>Фабрики и seeders - это инструмент для заполнения таблиц фейковыми значениями. Реализуица это путем написания неких правил а потом создания стольких записей сколько нам нужно. Чтобы создать фабрику и сразу привязать к таблице: php artisan make:migration PostFactory --model=Post</li>
        <li>В MVC с той или иной таблицой общается та или иная модель. Чтобы создать модель: php artisan make:model Post -m - создаст модель и миграцию. Обратите внимание что по-умаолчнию к имени модели буден добавлена буква "s", то есть множественное число - имено так будет называться таблица в базе данных. То есть по-умолчанию: модель user общается с таблицей users. Конечно это можно изменитиь например задав в клссе модели, с какой таблицей она должна ассоиироваться.</li>
        <li>$table->foreign('author_id')->refernces('id')->on('users') - создание внешнего ключа. Связали поле author_id в таблице posts, то есть автора статьи и поле id из таблицы users, то есть с id юзера. Он кстати тут не указывал ->index(), у меня тоже будет работаь?</li>
        <li>Базы данных</li>
        <li>
            Чтобы объединить таблицы join('таблица с которой связаться', 'по какому полю', 'как', поле)
            Post::join('users', 'author_id', '=', 'users.id')
            Сортировка:
            orderBy('поле', 'как ')
            orderBy('posts.created_at', 'desc')
            Пагинация
            paginate('по сколько')
            {{-- {{ $var->links() }} --}}
            Where/orWhere
            ('поле', 'like', 'что искать')->get()
        </li>
        <li>
            Чем отличается route(), url(), asset(). И когда, что используется?
            Вроде так:
            asset() - подключать статику
            route() - по имени маршрута url
            url()
        </li>
        <li>
            Вроде обращаться к полям, когда мы связываем таблицы можно так: user.id  или id?
        </li>
        <li>Как получать параметры из строки запроса. Как получать данные из полей формы.</li>
        <li>yii 2 артем прыгин. там тоже годно + yii2 тоже надо знать, чтобы знать 2 фреймворка. Также иам показано как делать корзину + сайт для портфолио есть.</li>
        <li>Новый экземпляр класса модели создаетя когда мы хотим сделать новую запись. Логично.</li>
        <li>php, js</li>
        <li>Обычно в базе данных хранится ссылка на картинку. Также картинки нужно будет физически перемещать в какую-то папку. Если загрузить через форму картинку они попадают в папку storage, напрямую взаимодействовать с этой папкой не будем, а будем перемещать картинку из storage в public.
        Сначала делаем: php artisan storage:link - этой командой artisan связал папку storage в public с глобальной папкой storage.
        урок 5, 4 минута - 8 мин
        </li>
        <li>
            route('test')->with('success', 'успшено создали псоат!')
            Чтобы обратится к флешки: session('success'), к примеру.
            После перезагрузки страницы он иисчезают. Я так понял их получает только 1 запрос, которому мы перенаправляем.
        </li>
        <li>
            {{-- {{ $post->created_at->diffForHumnax() }} --}}
            только не зубудьте моенять locale на ru в app.php и в layout.blade.php
        </li>
        <li>
            А еще он к массиву к значениям через стрелку обращается, я забыл. Там два варианта? через стрелку и через фигурные скобки?
        </li>
        <li>
            метод patch он использовал для роута, который отправляет на страницу редактирования поста который уже существует. Ну вообщем для метода update в ресурсном котролере.
            Ну а метод delete для методы destroy в ресурсном контролере.
        </li>
        <li>Директива include просто вставляет 1 шаблон в другой?</li>
        <li>
            Когда он сохранял пост он выызвал метод save(),
            когда обновлял update(),
            когда удалял delete(),
            когда искал find()
        </li>
        <li>
            В документации для title делали так:
            {{-- @yield('title', 'default value')
            @section('title', 'new title') --}}
            А он сделал так:
            {{-- {{ $title }} --}}
            extends(layouts.layout, ['title' => 'new title'])
            То есть он просто объявил переменную и значения для нее в директиве, которая указывает что наследует дочерний элемент.
        </li>
        <li>
            Для валидации мы создадим класс который будет овтечать за валидацию он будет принимать запрос и валидировать его. Везде где мы используем класс Requist (это метод записи и update) мы заменим на наш класс, который предусматривает валидацию.
            php artisan make:requist PostRequist - создаст готовый шаблон где мы можем прописывать правила валидации для запросов.
            Подключаем PostRequist и заменяем его вместо Requist.
            Пример правил:
            public function rules() {
                return [
                    'title' => 'required|min:3|max:40',
                ];
            }
            Если title не прошел проверку то ошибка валидации автоматически записывается в сессию.
            В переменной $errors.
            $errors->any()
            $errors->all() as $error
            Ошибка выводят на английском, можете зайди в resources/lang/ и папку en скопировать и поменять на ru, изменив все ошибки на руссклм. Вам нужно менять validation.php - тут ошибки валидации.
            Чтобы поменять attributes на русский лад, то снизу есть массив attributes где можно прописывать перевод.
        </li>
        <li>
            чтобы в форме отобразить предыдущие введениые данные пользователем:
            {{-- <input name='title'> --}}
            {{-- {{ old('title') }} --}}
        </li>
        <li>
            img => 'mimes:jpeg,png|max:5000'
        </li>
        <li>
            В Laravel из коробки встроена система авторизации, просто нужно запустить команду.
            php artisan make:auth
            Команда много что создает в web путь записывает, шаблоны и layout. Он скопировал то что ему нужно из app.playout, который создался в папке layouts.
        </li>
        <li>
            но это проверка только на строне клиента
            {{-- @auth  ... @endauth --}} - директива, которая проверяет авторизирован ли пользовать
        </li>
        <li>
            Если пользователь авторизировался, то у него есть возможность работать с крассом Auth и с его методами. Я так понял.
            Auth::user()->id() - если пользователь автоиризровался то к примеру, так можно посмотреть id пользователя.
        </li>
        <li>
            проверка со стороны сервера.
            у него тут блок поэтому он просто в методах которые обновляют удаляют и редактируют постыф написал:
            if ($post->author_id != Auth::user()->id) {return rededirect()}
        </li>
        <li>
            должна быть проверка как с клиента так и с сервера.
        </li>
        <li>
            return redirect()->route()->withErrors('Ерроррррр');
        </li>
        <li>
            В чем отличие with() и withErrors()?
            я ак понимаю with записывает в сессию по ключу который мы укажем, то что мы укажем.
            А withErrors записываем в массив $errors все.
        </li>
        <li>
            Каким образом можно запретить не авторизрованному пользователю посещать те или иные страницы?
            В вашем контролере в конструкторе прописать логику:
            public function __construct() {
                $this->middleware('auth')->except('index', 'show');
            }
            Если не авторизованный пользователь попытается использовать методы из этого контроля (ну то есть зайти на какие то адреса), кромя index и show то его по правилам middleware('auth'), который отвечает за авторизацию, аунтефикацию и допуска пользователя к той или иной странице в зависимости от того авторизирован ли он или нет.
        </li>
        <li>
            Если используете функции для работы с введенные пользователем данными не встреонные в Laravel, например $_GET['search'], не забывайте вызывать htmlspecialchars().
        </li>
        <li>
            Вообще все ваши ссылки нужно смотреть и добавлять защиту, это важно. Скрывать ошибки также нужно.
        </li>
        <li>
            Кстати мне кажется Route::fallback(), можно использовать что возвращать 404 ошибку.
        </li>
        <li>
            Чтобы изменит иь 404 страницу, создайте папку errors, и там файл 404.blade.php. По-умолчанию 404 ошибка создает из коробки, но если мы создадим свой шаблон, то будет использоваться он.
        </li>
        <li>
            // technologies
            $table->id();
            // categories
            $table->bigInteger('technology')->unsigned();
            $table->foreign('technology')->references('id')->on('technologies');
        </li>
        <li>{{ $user }}</li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
</div>












@endsection


<style>
    .test {
        color: #6aa891;
        margin: 0.5em 0;
        font-size: 1em;
    }
</style>

