@extends('layouts.mainLayout')

@section('content')
<div class="themes">
    <h1 class="themes__title">
        Безопасность
    </h1>
<div class="theme">
    <h2 class="theme__title">
        Аунтефикация
    </h2>
    <p class="theme__text">
        В Laravel сделать аутентификацию очень просто. Фактически, почти всё сконфигурировано для вас уже изначально. Конфигурационный файл аутентификации расположен в config/auth.php, который содержит несколько хорошо описанных опций для тонкой настройки поведения служб аутентификации.
По сути средства аутентификации Laravel состоят из "гвардов" и "провайдеров". Гварды определяют то, как именно аутентифицируются пользователи, для каждого запроса. Например, Laravel поставляется с гвардом session, который поддерживает состояние аутентифицированности с помощью хранилища сессий и кук.
Провайдеры определяют то, как именно пользователи извлекаются из вашей базы данных. Laravel поставляется с поддержкой извлечения пользователей с помощью Eloquent и конструктора запросов БД. Но при необходимости вы можете определить дополнительные провайдеры для своего приложения.
Не переживайте, если сейчас это звучит слишком запутанно! Для большинства приложений никогда не потребуется изменять стандартные настройки аутентификации.
    </p>
<h3 class="theme__subtitle">
    Требования для базы данных
</h3>
<p class="theme__text">
    По умолчанию Laravel включает модель App \ Models \ User Eloquent в ваш каталог app / Models. Эта модель может использоваться с драйвером аутентификации Eloquent по умолчанию. Если ваше приложение не использует Eloquent, вы можете использовать драйвер аутентификации базы данных, который использует построитель запросов Laravel.

При построении схемы базы данных для модели App \ Models \ User убедитесь, что длина столбца пароля составляет не менее 60 символов. Было бы неплохо сохранить длину столбца строки по умолчанию в 255 символов.

Кроме того, вы должны убедиться, что ваша таблица пользователей (или эквивалентная) содержит строку, допускающую значение NULL, столбец Remember_token из 100 символов. Этот столбец будет использоваться для хранения токена для пользователей, которые выбирают опцию «запомнить меня» при входе в ваше приложение.
</p>
<h3 class="theme__subtitle">Обзор экосистемы</h3>
<p class="theme__text">
    Laravel предлагает несколько пакетов, связанных с аутентификацией. Прежде чем продолжить, мы рассмотрим общую экосистему аутентификации в Laravel и обсудим предназначение каждого пакета.

Во-первых, рассмотрим, как работает аутентификация. При использовании веб-браузера пользователь вводит свое имя пользователя и пароль через форму входа. Если эти учетные данные верны, приложение сохранит информацию об аутентифицированном пользователе в пользовательском сеансе. Файл cookie, выпущенный для браузера, содержит идентификатор сеанса, чтобы последующие запросы к приложению могли связать пользователя с правильным сеансом. После получения файла cookie сеанса приложение извлечет данные сеанса на основе идентификатора сеанса, обратите внимание, что информация аутентификации была сохранена в сеансе, и будет считать пользователя «аутентифицированным».

Когда удаленной службе требуется пройти аутентификацию для доступа к API, файлы cookie обычно не используются, поскольку нет веб-браузера. Вместо этого удаленная служба отправляет токен API в API при каждом запросе. Приложение может проверить входящий токен по таблице допустимых токенов API и «аутентифицировать» запрос как выполняемый пользователем, связанным с этим токеном API.
</p>
<h3 class="theme__subtitle">Встроенные службы аутентификации браузера Laravel</h3>
<p class="theme__text">Laravel включает встроенные сервисы аутентификации и сеанса, которые обычно доступны через фасады Auth и Session. Эти функции обеспечивают аутентификацию на основе файлов cookie для запросов, которые инициируются из веб-браузеров. Они предоставляют методы, позволяющие проверять учетные данные пользователя и аутентифицировать пользователя. Кроме того, эти службы будут автоматически сохранять правильные данные в сеансе пользователя и выпускать соответствующий файл cookie сеанса. Обсуждение того, как использовать эти службы, содержится в этой документации.</p>
<h3 class="theme__subtitle">Jetstream / Fortify</h3>
<p class="theme__text">
    Как описано в этой документации, вы можете взаимодействовать с этими службами аутентификации вручную, чтобы создать собственный уровень аутентификации вашего приложения. Однако, чтобы помочь вам начать работу быстрее, мы выпустили бесплатные пакеты, которые обеспечивают надежную и современную основу всего уровня аутентификации. Эти пакеты - Laravel Jetstream и Laravel Fortify.

Laravel Fortify - это бэкэнд безголовой аутентификации для Laravel, который реализует многие функции, описанные в этой документации, включая аутентификацию на основе файлов cookie, а также другие функции, такие как двухфакторная аутентификация и проверка электронной почты. Laravel Jetstream - это пользовательский интерфейс, который использует и предоставляет сервисы аутентификации Fortify с красивым современным пользовательским интерфейсом на основе Tailwind CSS, Laravel Livewire и / или Inertia.js. Laravel Jetstream, помимо аутентификации файлов cookie на основе браузера, включает встроенную интеграцию с Laravel Sanctum для аутентификации токена API. Предложения аутентификации API Laravel обсуждаются ниже.
</p>
<h3 class="theme__subtitle">Laravel's API Authentication Services</h3>
<p class="theme__text">
    Laravel предоставляет два дополнительных пакета, которые помогут вам в управлении токенами API и аутентификации запросов, сделанных с помощью токенов API: Passport и Sanctum. Обратите внимание, что эти библиотеки и встроенные в Laravel библиотеки аутентификации на основе файлов cookie не являются взаимоисключающими. Эти библиотеки в основном ориентированы на аутентификацию токена API, в то время как встроенные службы аутентификации ориентированы на аутентификацию браузера на основе файлов cookie. Многие приложения будут использовать как встроенные службы аутентификации Laravel на основе файлов cookie, так и один из пакетов аутентификации API Laravel.
</p>
<h3 class="theme__subtitle">Passport</h3>
<p class="theme__text">
    Passport - это провайдер аутентификации OAuth2, предлагающий различные «типы прав доступа» OAuth2, которые позволяют выпускать различные типы токенов. В общем, это надежный и сложный пакет для аутентификации API. Однако большинству приложений не требуются сложные функции, предлагаемые спецификацией OAuth2, что может сбивать с толку как пользователей, так и разработчиков. Кроме того, разработчики исторически не понимали, как аутентифицировать приложения SPA или мобильные приложения с помощью провайдеров аутентификации OAuth2, таких как Passport.
</p>
<h3 class="theme__subtitle">Sanctum</h3>
<p class="theme__text">
    В ответ на сложность OAuth2 и путаницу разработчиков мы решили создать более простой и оптимизированный пакет аутентификации, который мог бы обрабатывать как сторонние веб-запросы из веб-браузера, так и запросы API через токены. Эта цель была реализована с выпуском Laravel Sanctum, который следует рассматривать как предпочтительный и рекомендуемый пакет аутентификации для приложений, которые будут предлагать собственный веб-интерфейс в дополнение к API или будут работать на одностраничном приложении, которое существует отдельно от внутреннего приложения Laravel или приложений, предлагающих мобильный клиент.

Laravel Sanctum - это гибридный пакет аутентификации через Интернет / API, который может управлять всем процессом аутентификации вашего приложения. Это возможно, потому что когда приложения на основе Sanctum получают запрос, Sanctum сначала определяет, содержит ли запрос файл cookie сеанса, который ссылается на сеанс, прошедший проверку подлинности. Sanctum выполняет это, вызывая встроенные службы аутентификации Laravel, которые мы обсуждали ранее. Если запрос не аутентифицируется с помощью файла cookie сеанса, Sanctum проверит запрос на наличие токена API. Если присутствует токен API, Sanctum аутентифицирует запрос с помощью этого токена. Чтобы узнать больше об этом процессе, обратитесь к документации Sanctum «как это работает».

Laravel Sanctum - это пакет API, который мы выбрали для включения в каркас аутентификации Laravel Jetstream, потому что мы считаем, что он лучше всего подходит для большинства потребностей аутентификации веб-приложений.
</p>
<h3 class="theme__subtitle">Summary & Choosing Your Stack</h3>
<p class="theme__text">
    Таким образом, если ваше приложение будет доступно через браузер, ваше приложение будет использовать встроенные службы аутентификации Laravel.

Затем, если ваше приложение предлагает API, вы должны выбрать между Passport или Sanctum, чтобы обеспечить аутентификацию токена API для вашего приложения. В целом, по возможности следует отдавать предпочтение Sanctum, поскольку это простое и полное решение для аутентификации API, аутентификации SPA и мобильной аутентификации, включая поддержку «областей» или «возможностей».

Passport можно выбрать, если вашему приложению абсолютно необходимы все функции, предоставляемые спецификацией OAuth2.

И, если вы хотите быстро начать работу, мы рады рекомендовать Laravel Jetstream как быстрый способ запустить новое приложение Laravel, которое уже использует наш предпочтительный стек аутентификации встроенных служб аутентификации Laravel и Laravel Sanctum.
</p>
<h3 class="theme__subtitle">Краткое руководство по аутентификации</h3>
<p class="theme__text">
    В этой части документации обсуждается аутентификация пользователей с помощью пакета Laravel Jetstream, который включает в себя скаффолдинг пользовательского интерфейса, который поможет вам быстро начать работу. Если вы хотите напрямую интегрироваться с системами аутентификации Laravel, ознакомьтесь с документацией по аутентификации пользователей вручную.
</p>
<h4 class="theme_subtitlex2">Маршрутизация</h4>
<p class="theme__text">
    Пакет laravel / jetstream от Laravel обеспечивает быстрый способ формирования всех маршрутов, представлений и другой внутренней логики, необходимой для аутентификации, с помощью нескольких простых команд:
</p>
<code>
<pre>
    composer require laravel/jetstream

// Install Jetstream with the Livewire stack...
php artisan jetstream:install livewire

// Install Jetstream with the Inertia stack...
php artisan jetstream:install inertia
</pre>
</code>
<p class="theme__text">
    Эту команду следует использовать в новых приложениях, она установит представление макета, представления регистрации и входа в систему, а также маршруты для всех конечных точек аутентификации. Также будет сгенерирован маршрут / дашборд для обработки запросов после входа в дашборд вашего приложения.
</p>
<h4 class="theme_subtitlex2">Creating Applications Including Authentication</h4>
<p class="theme__text">
    Если вы запускаете новое приложение и хотите включить каркас аутентификации, вы можете использовать директиву --jet при создании приложения через установщик Laravel. Эта команда создаст новое приложение со всеми скомпилированными и установленными каркасами аутентификации:
</p>
<code>
<pre>
    laravel new kitetail --jet
</pre>
</code>
<p class="theme__text">
    To learn more about Jetstream, please visit the official Jetstream documentation.
</p>
<h4 class="theme_subtitlex2">Views</h4>
<p class="theme__text">
    Как упоминалось в предыдущем разделе, команда php artisan jetstream: install пакета laravel / jetstream создаст все представления, необходимые для аутентификации, и поместит их в каталог resources / views / auth.

Jetstream также создаст каталог resources / views / layouts, содержащий базовый макет для вашего приложения. Все эти представления используют фреймворк Tailwind CSS, но вы можете настраивать их по своему усмотрению.
</p>
<h4 class="theme_subtitlex2">Authenticating</h4>
<p class="theme__text">
    Теперь, когда ваше приложение подготовлено для аутентификации, вы готовы к регистрации и аутентификации! Вы можете просто получить доступ к своему приложению в браузере, поскольку контроллеры аутентификации Jetstream уже содержат логику для аутентификации существующих пользователей и сохранения новых пользователей в базе данных.
</p>
<h4 class="theme_subtitlex2">Path Customization</h4>
<p class="theme__text">
    Когда пользователь успешно аутентифицирован, он обычно будет перенаправлен на URI / home. Вы можете настроить путь перенаправления после аутентификации, используя константу HOME, определенную в вашем RouteServiceProvider:
</p>
<code>
<pre>
    public const HOME = '/home';
</pre>
</code>
<p class="theme__text">
При использовании Laravel Jetstream процесс установки Jetstream изменит значение константы HOME на / dashboard.
</p>
<h3 class="theme__subtitle">Retrieving The Authenticated User</h3>
<p class="theme__text">
    При обработке входящего запроса вы можете получить доступ к аутентифицированному пользователю через фасад Auth:
</p>
<code>
<pre>
    use Illuminate\Support\Facades\Auth;

// Get the currently authenticated user...
$user = Auth::user();

// Get the currently authenticated user's ID...
$id = Auth::id();
</pre>
</code>
<p class="theme__text">
    В качестве альтернативы, как только пользователь аутентифицирован, вы можете получить доступ к аутентифицированному пользователю через экземпляр Illuminate \ Http \ Request. Помните, что классы с указанием типа будут автоматически добавлены в методы вашего контроллера. Путем указания типа объекта Illuminate \ Http \ Request вы можете получить удобный доступ к аутентифицированному пользователю из любого метода контроллера в вашем приложении:
</p>
<code>
<pre>
    namespace App\Http\Controllers;

use Illuminate\Http\Request;

class FlightController extends Controller
{
    /**
     * Get a list of all available flights.
     *
     * @param  Request  $request
     * @return Response
     */
    public function update(Request $request)
    {
        // $request->user() returns an instance of the authenticated user...
    }
}
</pre>
</code>
<h3 class="theme__subtitle">Determining If The Current User Is Authenticated</h3>
<p class="theme__text">
    Чтобы определить, вошел ли пользователь в ваше приложение, вы можете использовать метод check на фасаде Auth, который вернет true, если пользователь аутентифицирован:
</p>
<code>
<pre>
    use Illuminate\Support\Facades\Auth;

if (Auth::check()) {
    // The user is logged in...
}
</pre>
</code>
<p class="theme__text">
    Несмотря на то, что можно определить, аутентифицирован ли пользователь с помощью метода проверки, вы обычно будете использовать промежуточное программное обеспечение, чтобы проверить, аутентифицирован ли пользователь, прежде чем разрешить пользователю доступ к определенным маршрутам / контроллерам. Чтобы узнать больше об этом, ознакомьтесь с документацией по защите маршрутов.
</p>
<h3 class="theme__subtitle">Protecting Routes</h3>
<p class="theme__text">
    Промежуточное ПО маршрута может использоваться только для того, чтобы разрешить аутентифицированным пользователям доступ к заданному маршруту. Laravel поставляется с промежуточным ПО для аутентификации, которое ссылается на класс Illuminate \ Auth \ Middleware \ Authenticate. Поскольку это промежуточное ПО уже зарегистрировано в вашем HTTP-ядре, все, что вам нужно сделать, это присоединить промежуточное ПО к определению маршрута:
</p>
<code>
<pre>
    Route::get('flights', function () {
        // Only authenticated users may enter...
    })->middleware('auth');
</pre>
</code>
<h3 class="theme__subtitle">Redirecting Unauthenticated Users</h3>
<p class="theme__text">
    Когда промежуточное ПО auth обнаруживает неавторизованного пользователя, оно перенаправляет пользователя на имя входа в систему. Вы можете изменить это поведение, обновив функцию redirectTo в файле app / Http / Middleware / Authenticate.php:
</p>
<code>
<pre>
    /**
 * Get the path the user should be redirected to.
 *
 * @param  \Illuminate\Http\Request  $request
 * @return string
 */
protected function redirectTo($request)
{
    return route('login');
}
</pre>
</code>
<h3 class="theme__subtitle">Specifying A Guard</h3>
<p class="theme__text">
    При присоединении промежуточного программного обеспечения аутентификации к маршруту вы также можете указать, какое средство защиты должно использоваться для аутентификации пользователя. Указанный охранник должен соответствовать одному из ключей в массиве guards вашего файла конфигурации auth.php:
</p>
<code>
<pre>
    Route::get('flights', function () {
        // Only authenticated users may enter...
    })->middleware('auth:api');
</pre>
</code>
<h3 class="theme__subtitle">
    Login Throttling
</h3>
<p class="theme__text">
    Если вы используете Laravel Jetstream, ограничение скорости будет автоматически применяться к попыткам входа в систему. По умолчанию, пользователь не сможет войти в систему в течение одной минуты, если он не сможет предоставить правильные учетные данные после нескольких попыток. Регулирование уникально для имени пользователя / адреса электронной почты и их IP-адреса.

If you would like to rate limit your own routes, check out the rate limiting documentation.
</p>
<h3 class="theme__subtitle">
    Manually Authenticating Users
</h3>
<p class="theme__text">
    Вам не обязательно использовать шаблоны аутентификации, включенные в Laravel Jetstream. Если вы решите не использовать этот шаблон, вам нужно будет управлять аутентификацией пользователей напрямую, используя классы аутентификации Laravel. Не волнуйтесь, это круто!

Мы получим доступ к службам аутентификации Laravel через фасад Auth, поэтому нам нужно обязательно импортировать фасад Auth в верхней части класса. Затем давайте проверим метод попытки:
</p>
<code>
<pre>
    namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class LoginController extends Controller
{
    /**
     * Handle an authentication attempt.
     *
     * @param  \Illuminate\Http\Request $request
     *
     * @return Response
     */
    public function authenticate(Request $request)
    {
        $credentials = $request->only('email', 'password');

        if (Auth::attempt($credentials)) {
            // Authentication passed...
            return redirect()->intended('dashboard');
        }
    }
}
</pre>
</code>
<p class="theme__text">
    Метод attempt принимает массив пар ключ/значение в качестве первого аргумента. Значения массива будут использованы для поиска пользователя в таблице базы данных. Так, в приведённом выше примере пользователь будет получен по значению столбца email. Если пользователь будет найден, хешированный пароль, сохранённый в базе данных, будет сравниваться с хешированным значением password , переданным в метод через массив. Если два хешированных пароля совпадут, то для пользователя будет запущена новая аутентифицированная сессия.
Метод attempt вернет true, если аутентификация прошла успешно. В противном случае будет возвращён false.
Метод intended "редиректора" перенаправит пользователя к тому URL, к которому он обращался до того, как был перехвачен фильтром аутентификации. В этот метод можно передать запасной URI, на случай недоступности требуемого пути.
</p>
<h3 class="theme__subtitle">Указание дополнительных условий</h3>
<p class="theme__text">
    При необходимости вы можете добавить дополнительные условия к запросу аутентификации, помимо адреса e-mail и пароля. Например, можно проверить отметку "активности" пользователя:
</p>
<code>
<pre>
    if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) {
        // The user is active, not suspended, and exists.
    }
</pre>
</code>
<p class="theme__text">
    В этих примерах email не является обязательным вариантом, он приведён только для примера. Вы можете использовать какой угодно столбец, соответствующий "username" в вашей базе данных.
</p>
<h3 class="theme__subtitle">Обращение к конкретным экземплярам гварда</h3>
<p class="theme__text">
    С помощью метода guard фасада Auth вы можете указать, какой экземпляр гварда необходимо использовать. Это позволяет управлять аутентификацией для отдельных частей вашего приложения, используя полностью отдельные модели для аутентификации или таблицы пользователей.
Передаваемое в метод guard имя гварда должно соответствовать одному из защитников, настроенных в конфиге auth.php:
</p>
<code>
<pre>
    if (Auth::guard('admin')->attempt($credentials)) {
        //
    }
</pre>
</code>
<h3 class="theme__subtitle">Завершение сессии</h3>
<p class="theme__text">
    Для завершения сессии пользователя можно использовать метод logout фасада Auth. Он очистит информацию об аутентификации в сессии пользователя:
</p>
<code>
<pre>
    Auth::logout();
</pre>
</code>
<h3 class="theme__subtitle">Запоминание пользователей</h3>
<p class="theme__text">
    Если вы хотите обеспечить функциональность "запомнить меня" в вашем приложении, вы можете передать логическое значение как второй параметр методу attempt, который сохранит пользователя аутентифицированным на неопределённое время, или пока он вручную не выйдет из системы. Конечно, ваша таблица users должна содержать строковый столбец remember_token, который будет использоваться для хранения токенов "запомнить меня".
</p>
<code>
<pre>
    if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) {
        // The user is being remembered...
    }
</pre>
</code>
<p class="theme__text">
    Если вы "запоминаете" пользователей, то можете использовать метод viaRemember , чтобы определить, аутентифицировался ли пользователь, используя cookie "запомнить меня":
</p>
<code>
<pre>
    if (Auth::viaRemember()) {
        //
    }
</pre>
</code>
<h3 class="theme__subtitle">Другие методы аутентификации</h3>
<h4 class="theme_subtitlex2">Аутентификация экземпляра пользователя</h4>
<p class="theme__text">
    Если вам нужно зарегистрировать существующий пользовательский экземпляр в вашем приложении, вы можете вызвать метод входа в систему с пользовательским экземпляром. Данный объект должен быть реализацией контракта Illuminate \ Contracts \ Auth \ Authenticatable. Модель App \ Models \ User, включенная в Laravel, уже реализует этот интерфейс. Этот метод аутентификации полезен, когда у вас уже есть действующий экземпляр пользователя, например, сразу после регистрации пользователя в вашем приложении:
</p>
<code>
<pre>
    Auth::login($user);
    // Login and "remember" the given user...
Auth::login($user, true);
</pre>
</code>
<p class="theme__text">
    Вы можете указать экземпляр защиты, который хотите использовать:
</p>
<code>
<pre>
    Auth::guard('admin')->login($user);
</pre>
</code>
<h4 class="theme_subtitlex2">Аутентификация пользователя по ID</h4>
<p class="theme__text">
    Для входа пользователя в приложение по его идентификатору вы можете использовать метод loginUsingId. Этот метод принимает первичный ключ пользователя, которого вы хотите аутентифицировать:
</p>
<code>
<pre>
    Auth::loginUsingId(1);

// Login and "remember" the given user...
Auth::loginUsingId(1, true);
</pre>
</code>
<h4 class="theme_subtitlex2">Однократная аутентификация пользователя</h4>
<p class="theme__text">
    Вы можете использовать метод Once для входа пользователя в приложение для одного запроса. Никакие сеансы или файлы cookie не будут использоваться, что означает, что этот метод может быть полезен при создании API без сохранения состояния:
</p>
<code>
<pre>
if (Auth::once($credentials)) {
    //
}
</pre>
</code>
<h4 class="theme_subtitlex2">HTTP-аутентификация</h4>
<p class="theme__text">
    Базовая проверка подлинности HTTP обеспечивает быстрый способ проверки подлинности пользователей вашего приложения без создания специальной страницы «входа в систему». Для начала прикрепите к своему маршруту промежуточное ПО auth.basic. Промежуточное ПО auth.basic включено в структуру Laravel, поэтому вам не нужно его определять:
</p>
<code>
<pre>
    Route::get('profile', function () {
        // Only authenticated users may enter...
    })->middleware('auth.basic');
</pre>
</code>
<p class="theme__text">
    Когда посредник прикреплён к роуту, вы автоматически получите запрос данных для входа при обращении к роуту через браузер. По умолчанию посредник auth.basic будет использовать столбец email из записи пользователя в качестве "username".
</p>
<h4 class="theme_subtitlex2">Замечание по FastCGI</h4>
<p class="theme__text">Если вы используете PHP FastCGI, аутентификация HTTP Basic может работать некорректно из коробки. В файл .htaccess необходимо добавить следующие строки:</p>
<code>
<pre>
    RewriteCond %{HTTP:Authorization} ^(.+)$
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
</pre>
</code>
<h4 class="theme_subtitlex2">HTTP-аутентификация без сохранения состояния</h4>
<p class="theme__text">
    Вы также можете использовать базовую аутентификацию HTTP без установки файла cookie идентификатора пользователя в сеансе, что особенно полезно для аутентификации API. Для этого определите промежуточное программное обеспечение, которое вызывает метод onceBasic. Если метод OnceBasic не возвращает ответа, запрос может быть передан приложению дальше:
</p>
<code>
<pre>
    namespace App\Http\Middleware;

use Illuminate\Support\Facades\Auth;

class AuthenticateOnceWithBasicAuth
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, $next)
    {
        return Auth::onceBasic() ?: $next($request);
    }

}
</pre>
</code>
<p class="theme__text">
    Затем зарегистрируйте промежуточное ПО маршрута и прикрепите его к маршруту:
</p>
<code>
<pre>
    Route::get('api/user', function () {
        // Only authenticated users may enter...
    })->middleware('auth.basic.once');
</pre>
</code>
<h3 class="theme__subtitle">Logging Out</h3>
<p class="theme__text">Чтобы вручную вывести пользователей из вашего приложения, вы можете использовать метод выхода из фасада Auth. Это очистит информацию аутентификации в сеансе пользователя:</p>
<code>
<pre>
    use Illuminate\Support\Facades\Auth;

Auth::logout();
</pre>
</code>
<h3 class="theme__subtitle">Invalidating Sessions On Other Devices</h3>
<p class="theme__text">
    Laravel также предоставляет механизм для аннулирования и «выхода» из сеансов пользователя, которые активны на других устройствах, без аннулирования сеанса на их текущем устройстве. Эта функция обычно используется, когда пользователь меняет или обновляет свой пароль, и вы хотите аннулировать сеансы на других устройствах, сохранив аутентификацию текущего устройства.

Перед тем как начать, вы должны убедиться, что промежуточное ПО Illuminate \ Session \ Middleware \ AuthenticateSession присутствует и не прокомментировано в группе промежуточного программного обеспечения веб-класса app / Http / Kernel.php:
</p>
<code>
<pre>
    'web' => [
    // ...
    \Illuminate\Session\Middleware\AuthenticateSession::class,
    // ...
],
</pre>
</code>
<p class="theme__text">
    Затем вы можете использовать метод logoutOtherDevices на фасаде Auth. Этот метод требует, чтобы пользователь предоставил свой текущий пароль, который ваше приложение должно принять через форму ввода:
</p>
<code>
<pre>
    use Illuminate\Support\Facades\Auth;

Auth::logoutOtherDevices($password);
</pre>
</code>
<p class="theme__text">
    Когда вызывается метод logoutOtherDevices, другие сеансы пользователя будут полностью аннулированы, то есть они будут "отключены" от всех охранников, которыми они ранее были аутентифицированы.

При использовании промежуточного программного обеспечения AuthenticateSession в сочетании с настраиваемым именем маршрута для маршрута входа в систему необходимо переопределить неаутентифицированный метод в обработчике исключений вашего приложения, чтобы правильно перенаправить пользователей на страницу входа.
</p>
<h3 class="theme__subtitle">Password Confirmation</h3>
<p class="theme__text">
    При создании приложения вы можете иногда выполнять действия, требующие от пользователя подтверждения пароля перед выполнением действия. Laravel включает встроенное промежуточное программное обеспечение, чтобы упростить этот процесс. Реализация этой функции потребует от вас определения двух маршрутов: один маршрут для отображения представления, предлагающего пользователю подтвердить свой пароль, и один маршрут для подтверждения того, что пароль действителен, и перенаправления пользователя в предполагаемое место назначения.

В следующей документации обсуждается, как напрямую интегрироваться с функциями подтверждения пароля Laravel; однако, если вы хотите начать работу быстрее, пакет формирования шаблонов аутентификации Laravel Jetstream включает поддержку этой функции!
</p>
<h3 class="theme__subtitle">Configuration</h3>
<p class="theme__text">
    После подтверждения пароля пользователю не будет предлагаться повторно подтвердить пароль в течение трех часов. Однако вы можете настроить период времени, по истечении которого пользователю будет предложено повторно ввести пароль, изменив значение параметра конфигурации password_timeout в файле конфигурации аутентификации.
</p>
<h3 class="theme__subtitle">Routing</h3>
<h4 class="theme_subtitlex2">The Password Confirmation Form</h4>
<p class="theme__text">
    Сначала мы определим маршрут, который необходим для отображения представления, запрашивающего у пользователя подтверждение своего пароля:
</p>
<code>
<pre>
    Route::get('/confirm-password', function () {
        return view('auth.confirm-password');
    })->middleware(['auth'])->name('password.confirm');
</pre>
</code>
<p class="theme__text">
    Как и следовало ожидать, представление, возвращаемое этим маршрутом, должно иметь форму, содержащую поле пароля. Кроме того, не стесняйтесь включать в представление текст, который объясняет, что пользователь входит в защищенную область приложения и должен подтвердить свой пароль.
</p>
<h4 class="theme_subtitlex2">Confirming The Password</h4>
<p class="theme__text">
    Затем мы определим маршрут, который будет обрабатывать запрос формы из представления «подтвердить пароль». Этот маршрут будет отвечать за проверку пароля и перенаправление пользователя к месту назначения:
</p>
<code>
<pre>
    use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;

Route::post('/confirm-password', function (Request $request) {
    if (! Hash::check($request->password, $request->user()->password)) {
        return back()->withErrors([
            'password' => ['The provided password does not match our records.']
        ]);
    }

    $request->session()->passwordConfirmed();

    return redirect()->intended();
})->middleware(['auth', 'throttle:6,1'])->name('password.confirm');
</pre>
</code>
<p class="theme__text">
    Прежде чем двигаться дальше, давайте рассмотрим этот маршрут более подробно. Сначала определяется, что атрибут пароля запроса фактически соответствует паролю аутентифицированного пользователя. Если пароль действителен, нам нужно сообщить сеансу Laravel, что пользователь подтвердил свой пароль. Метод passwordConfirmed устанавливает метку времени в сеансе пользователя, которую Laravel может использовать, чтобы определить, когда пользователь последний раз подтвердил свой пароль. Наконец, мы можем перенаправить пользователя по назначению.
</p>
<h4 class="theme_subtitlex2">Protecting Routes</h4>
<p class="theme__text">
    Вы должны убедиться, что любому маршруту, выполняющему действие, требующее недавнего подтверждения пароля, назначено промежуточное программное обеспечение password.confirm. Это промежуточное программное обеспечение входит в стандартную установку Laravel и автоматически сохраняет предполагаемое место назначения пользователя в сеансе, чтобы пользователь мог быть перенаправлен в это место после подтверждения своего пароля. После сохранения предполагаемого пункта назначения пользователя в сеансе промежуточное ПО перенаправит пользователя на именованный маршрут password.confirm:
</p>
<code>
<pre>
    Route::get('/settings', function () {
        // ...
    })->middleware(['password.confirm']);

    Route::post('/settings', function () {
        // ...
    })->middleware(['password.confirm']);
</pre>
</code>
<h3 class="theme__subtitle">Добавление собственных гвардов</h3>
<p class="theme__text">
    Вы можете определить свои собственные средства защиты аутентификации, используя метод extend фасада Auth. Вы должны разместить этот вызов для расширения внутри поставщика услуг. Поскольку Laravel уже поставляется с AuthServiceProvider, мы можем разместить код в этом провайдере:
</p>
<code>
<pre>
    namespace App\Providers;

use App\Services\Auth\JwtGuard;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Auth;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * Register any application authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this->registerPolicies();

        Auth::extend('jwt', function ($app, $name, array $config) {
            // Return an instance of Illuminate\Contracts\Auth\Guard...

            return new JwtGuard(Auth::createUserProvider($config['provider']));
        });
    }
}
</pre>
</code>
<p class="theme__text">
    Как вы можете видеть в приведенном выше примере, обратный вызов, переданный методу расширения, должен возвращать реализацию Illuminate \ Contracts \ Auth \ Guard. Этот интерфейс содержит несколько методов, которые вам необходимо реализовать для определения настраиваемой защиты. После того, как ваш пользовательский охранник был определен, вы можете использовать его в конфигурации охранников вашего файла конфигурации auth.php:

</p>
<code>
<pre>
    'guards' => [
    'api' => [
        'driver' => 'jwt',
        'provider' => 'users',
    ],
],
</pre>
</code>
<h4 class="theme_subtitlex2">Closure Request Guards</h4>
<p class="theme__text">
    Самый простой способ реализовать настраиваемую систему аутентификации на основе HTTP-запросов - использовать метод Auth :: viaRequest. Этот метод позволяет вам быстро определить процесс аутентификации с помощью одного закрытия.

Для начала вызовите метод Auth :: viaRequest в методе загрузки вашего AuthServiceProvider. Метод viaRequest принимает имя драйвера аутентификации в качестве первого аргумента. Это имя может быть любой строкой, описывающей вашу индивидуальную защиту. Второй аргумент, передаваемый методу, должен быть Closure, который получает входящий HTTP-запрос и возвращает экземпляр пользователя или, если аутентификация не удалась, null:
</p>
<code>
<pre>
    use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

/**
 * Register any application authentication / authorization services.
 *
 * @return void
 */
public function boot()
{
    $this->registerPolicies();

    Auth::viaRequest('custom-token', function ($request) {
        return User::where('token', $request->token)->first();
    });
}
</pre>
</code>
<p class="theme__text">
    После того, как ваш пользовательский драйвер аутентификации был определен, вы используете его в качестве драйвера в конфигурации guards вашего файла конфигурации auth.php:
</p>
<code>
<pre>
    'guards' => [
    'api' => [
        'driver' => 'custom-token',
    ],
],
</pre>
</code>
<h4 class="theme_subtitlex2">Добавление собственных провайдеров пользователей</h4>
<p class="theme__text">
    Если вы не используете традиционную реляционную базу данных для хранения ваших пользователей, вам необходимо добавить в Laravel свой собственный провайдер аутентификации пользователей. Мы используем метод provider фасада Auth для определения своего провайдера:
</p>
<code>
<pre>
    namespace App\Providers;

use App\Extensions\RiakUserProvider;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Auth;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * Register any application authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this->registerPolicies();

        Auth::provider('riak', function ($app, array $config) {
            // Return an instance of Illuminate\Contracts\Auth\UserProvider...

            return new RiakUserProvider($app->make('riak.connection'));
        });
    }
}
</pre>
</code>
<p class="theme__text">
    После регистрации провайдера методом provider, вы можете переключиться на новый провайдер в файле настроек auth.php. Сначала определите провайдера provider, который использует ваш новый драйвер:
</p>
<code>
<pre>
    'providers' => [
    'users' => [
        'driver' => 'riak',
    ],
],
</pre>
</code>
<p class="theme__text">
    Затем вы можете использовать этот провайдер в вашей настройке guards:
</p>
<code>
<pre>
    'guards' => [
    'web' => [
        'driver' => 'session',
        'provider' => 'users',
    ],
],
</pre>
</code>
<h3 class="theme__subtitle">Контракт User Provider</h3>
<p class="theme__text">
    Реализации Illuminate\Contracts\Auth\UserProvider отвечают только за извлечение реализаций Illuminate\Contracts\Auth\Authenticatable из постоянных систем хранения, таких как MySQL, Riak, и т.п. Эти два интерфейса позволяют механизмам аутентификации Laravel продолжать функционировать независимо от того, как хранятся данные пользователей и какой тип класса использован для их представления.
Давайте взглянем на контракт Illuminate\Contracts\Auth\UserProvider:
</p>
<code>
<pre>
    namespace Illuminate\Contracts\Auth;

interface UserProvider
{
    public function retrieveById($identifier);
    public function retrieveByToken($identifier, $token);
    public function updateRememberToken(Authenticatable $user, $token);
    public function retrieveByCredentials(array $credentials);
    public function validateCredentials(Authenticatable $user, array $credentials);
}
</pre>
</code>
<p class="theme__text">
    Функция retrieveById обычно принимает ключ, отображающий пользователя, такой как автоинкрементный ID из базы данных MySQL. Реализация Authenticatable, соответствующая этому ID, должна быть получена и возвращена этим методом.
Функция retrieveByToken принимает пользователя по его уникальному $identifier и ключу $token "запомнить меня", хранящемуся в поле remember_token. Как и предыдущий метод, он должен возвращать реализацию Authenticatable.
Метод updateRememberToken обновляет поле remember_token пользователя $user значением нового $token. Новый ключ может быть как свежим ключом, назначенным при успешной попытке входа "запомнить меня", так и нулевым при выходе пользователя.
Метод retrieveByCredentials принимает массив авторизационных данных, переданных в метод Auth::attempt при попытке входа в приложение. Затем метод должен "запросить" у основного постоянного хранилища того пользователя, который соответствует этим авторизационным данным. Обычно этот метод выполняет запрос с условием "where" для $credentials['username']. Затем метод должен вернуть реализацию Authenticatable. Этот метод не должен пытаться проверить пароль или аутентифицировать пользователя.
Метод validateCredentials должен сравнить данного $user с $credentials для аутентификации пользователя. Например, этот метод может сравнить строку $user->getAuthPassword() с Hash::check для сравнения значения $credentials['password']. Этот метод должен возвращать true или false, указывая верен ли пароль.
</p>
<h3 class="theme__subtitle">Контракт Authenticatable</h3>
<p class="theme__text">
    Теперь, когда мы изучили каждый из методов UserProvider, давайте взглянем на контракт Authenticatable. Помните, что поставщик должен возвращать реализации этого интерфейса из методов retrieveById, retrieveByToken и retrieveByCredentials:
</p>
<code>
<pre>
    namespace Illuminate\Contracts\Auth;

interface Authenticatable
{
    public function getAuthIdentifierName();
    public function getAuthIdentifier();
    public function getAuthPassword();
    public function getRememberToken();
    public function setRememberToken($value);
    public function getRememberTokenName();
}
</pre>
</code>
<p class="theme__text">
    Этот интерфейс довольно прост. Метод getAuthIdentifierName должен возвращать имя поля "первичного ключа» пользователя", а метод getAuthIdentifier - "первичный ключ" пользователя. При использовании MySQL это будет автоинкрементный первичный ключ. Метод getAuthPassword должен возвращать хешированный пароль пользователя. Этот интерфейс позволяет системе аутентификации работать с классом User, независимо от используемой ORM и уровня абстракции хранилища. По умолчанию Laravel содержит в директории app класс User, который реализует этот интерфейс. Вы можете подсмотреть в нём пример реализации.
</p>
<h3 class="theme__subtitle">События</h3>
<p class="theme__text">
    Laravel вызывает множество событий во время процесса аутентификации. Вы можете прикрепить слушателей к этим событиям в своем EventServiceProvider:
</p>
<code>
<pre>
    /**
 * The event listener mappings for the application.
 *
 * @var array
 */
protected $listen = [
    'Illuminate\Auth\Events\Registered' => [
        'App\Listeners\LogRegisteredUser',
    ],

    'Illuminate\Auth\Events\Attempting' => [
        'App\Listeners\LogAuthenticationAttempt',
    ],

    'Illuminate\Auth\Events\Authenticated' => [
        'App\Listeners\LogAuthenticated',
    ],

    'Illuminate\Auth\Events\Login' => [
        'App\Listeners\LogSuccessfulLogin',
    ],

    'Illuminate\Auth\Events\Failed' => [
        'App\Listeners\LogFailedLogin',
    ],

    'Illuminate\Auth\Events\Validated' => [
        'App\Listeners\LogValidated',
    ],

    'Illuminate\Auth\Events\Verified' => [
        'App\Listeners\LogVerified',
    ],

    'Illuminate\Auth\Events\Logout' => [
        'App\Listeners\LogSuccessfulLogout',
    ],

    'Illuminate\Auth\Events\CurrentDeviceLogout' => [
        'App\Listeners\LogCurrentDeviceLogout',
    ],

    'Illuminate\Auth\Events\OtherDeviceLogout' => [
        'App\Listeners\LogOtherDeviceLogout',
    ],

    'Illuminate\Auth\Events\Lockout' => [
        'App\Listeners\LogLockout',
    ],

    'Illuminate\Auth\Events\PasswordReset' => [
        'App\Listeners\LogPasswordReset',
    ],
];

</pre>
</code>
</div>
<div class="theme">
    <h2 class="theme__title">Авторизация</h2>
    <p class="theme__text">
        В дополнение к изначально предоставленным службам аутентификации, Laravel также предоставляет простой способ авторизовать действия пользователя в отношении данного ресурса. Как и в случае с аутентификацией, подход Laravel к авторизации прост, и есть два основных способа авторизации действий: шлюзы и политики.
Думайте о шлюзах и политиках, как о маршрутах и контроллерах. Шлюзы обеспечивают простое решение на основе замыканий, в свою очередь политики, как контроллеры, группируют свою логику вокруг конкретной модели или ресурса. Сначала мы разберем шлюзы, а затем рассмотрим политики.
Важно не рассматривать шлюзы и политики как взаимоисключающие вещи. Большинство приложений, скорее всего, содержат смесь шлюзов и политик, и это прекрасно! Шлюзы наиболее применимы к действиям, которые не связаны с какой-либо моделью или ресурсом, например, просмотр панели администратора. В противоположность этому, политика должна быть использована, если вы хотите разрешить действие для конкретной модели или ресурса.
    </p>
    <h3 class="theme__subtitle">Шлюзы</h3>
<h4 class="theme_subtitlex2">Написание шлюзов</h4>
<p class="theme__text">
    Шлюзы (гейты, gates) - это функции-замыкания, которые определяют, имеет ли пользователь право выполнить данное действие; они обычно определяются в классе App\Providers\AuthServiceProvider с помощью фасада Gate. Шлюзы всегда получают экземпляр пользователя в качестве первого аргумента. Также они могут принимать дополнительные аргументы, например, соответствующую модель Eloquent:

</p>
<code>
<pre>
    /**
 * Register any authentication / authorization services.
 *
 * @return void
 */
public function boot()
{
    $this->registerPolicies();

    Gate::define('edit-settings', function ($user) {
        return $user->isAdmin;
    });

    Gate::define('update-post', function ($user, $post) {
        return $user->id === $post->user_id;
    });
}
</pre>
</code>
<p class="theme__text">
    Шлюзы также можно задать, используя строку анонимной функции стиля Class@method, как контроллеры:

</p>
<code>
<pre>
    use App\Policies\PostPolicy;
    /**
 * Register any authentication / authorization services.
 *
 * @return void
 */
public function boot()
{
    $this->registerPolicies();

    Gate::define('update-post', [PostPolicy::class, 'update']);
}
</pre>
</code>
<h4 class="theme_subtitlex2">Авторизация действий</h4>
<p class="theme__text">
    Чтобы авторизовать действие с помощью шлюзов нужно использовать методы allows или denies. Обратите внимание, что этим методам не нужно передавать текущего аутентифицированного пользователя. Laravel автоматически подставит текущего пользователя в замыкание шлюза:
</p>
<code>
<pre>
    if (Gate::allows('edit-settings')) {
        // The current user can edit settings
    }

    if (Gate::allows('update-post', $post)) {
        // The current user can update the post...
    }

    if (Gate::denies('update-post', $post)) {
        // The current user can't update the post...
    }
</pre>
</code>
<p class="theme__text">
    Если вы хотите определить, авторизован ли конкретный пользователь для выполнения действия, вы можете использовать метод forUser на фасаде Gate:
</p>
<code>
<pre>
    if (Gate::forUser($user)->allows('update-post', $post)) {
        // The user can update the post...
    }

    if (Gate::forUser($user)->denies('update-post', $post)) {
        // The user can't update the post...
    }
</pre>
</code>
<p class="theme__text">
    Вы можете разрешить несколько действий одновременно с помощью методов any или none:
</p>
<code>
<pre>
    if (Gate::any(['update-post', 'delete-post'], $post)) {
        // The user can update or delete the post
    }

    if (Gate::none(['update-post', 'delete-post'], $post)) {
        // The user cannot update or delete the post
    }
</pre>
</code>
<h4 class="theme_subtitlex2">Authorizing Or Throwing Exceptions</h4>
<p class="theme__text">
    Если вы хотите попытаться авторизовать действие и автоматически выбросить исключение Illuminate \ Auth \ Access \ AuthorizationException, если пользователю не разрешено выполнять данное действие, вы можете использовать метод Gate :: authorize. Экземпляры AuthorizationException автоматически преобразуются в ответ HTTP 403:
</p>
<code>
<pre>
    Gate::authorize('update-post', $post);

// The action is authorized...
</pre>
</code>
<h4 class="theme_subtitlex2">Supplying Additional Context</h4>
<p class="theme__text">
    Методы шлюза для авторизации способностей (разрешает, запрещает, проверяет, любой, нет, авторизовать, может, нельзя) и директивы Blade авторизации (@can, @cannot, @canany) могут получать массив в качестве второго аргумента. Эти элементы массива передаются шлюзу в качестве параметров и могут использоваться в качестве дополнительного контекста при принятии решений об авторизации:
</p>
<code>
<pre>
    Gate::define('create-post', function ($user, $category, $extraFlag) {
        return $category->group > 3 && $extraFlag === true;
    });

    if (Gate::check('create-post', [$category, $extraFlag])) {
        // The user can create the post...
    }
</pre>
</code>
<h4 class="theme_subtitlex2">Gate Responses</h4>
<p class="theme__text">
    До сих пор мы исследовали только элементы, возвращающие простые логические значения. Однако иногда вы можете захотеть вернуть более подробный ответ, включая сообщение об ошибке. Для этого вы можете вернуть Illuminate \ Auth \ Access \ Response со своего гейта:
</p>
<code>
<pre>
    use Illuminate\Auth\Access\Response;
use Illuminate\Support\Facades\Gate;

Gate::define('edit-settings', function ($user) {
    return $user->isAdmin
                ? Response::allow()
                : Response::deny('You must be a super administrator.');
});
</pre>
</code>
<p class="theme__text">
    При возврате ответа авторизации от вашего шлюза метод Gate :: allow все равно будет возвращать простое логическое значение; однако вы можете использовать метод Gate :: inspect, чтобы получить полный ответ авторизации, возвращенный шлюзом:
</p>
<code>
<pre>
    $response = Gate::inspect('edit-settings', $post);

if ($response->allowed()) {
    // The action is authorized...
} else {
    echo $response->message();
}
</pre>
</code>
<p class="theme__text">
    Конечно, при использовании метода Gate :: authorize для выдачи исключения AuthorizationException, если действие не авторизовано, сообщение об ошибке, предоставленное ответом авторизации, будет передано в ответ HTTP:
</p>
<code>
<pre>
    Gate::authorize('edit-settings', $post);

// The action is authorized...
</pre>
</code>
<h4 class="theme_subtitlex2">Intercepting Gate Checks</h4>
<p class="theme__text">
    Иногда вы можете захотеть предоставить все возможности конкретному пользователю. Вы можете использовать метод before для определения обратного вызова, который запускается перед всеми другими проверками авторизации:
</p>
<code>
<pre>
    Gate::before(function ($user, $ability) {
        if ($user->isSuperAdmin()) {
            return true;
        }
    });
</pre>
</code>
<p class="theme__text">
    Если обратный вызов before возвращает ненулевой результат, этот результат будет считаться результатом проверки.

Вы можете использовать метод after для определения обратного вызова, который будет выполняться после всех других проверок авторизации:
</p>
<code>
<pre>
    Gate::after(function ($user, $ability, $result, $arguments) {
        if ($user->isSuperAdmin()) {
            return true;
        }
    });
</pre>
</code>
<p class="theme__text">
    Подобно предыдущей проверке, если обратный вызов after возвращает ненулевой результат, этот результат будет считаться результатом проверки.
</p>
<h3 class="theme__subtitle">Создание политик</h3>
<h4 class="theme_subtitlex2">Генерация политик</h4>
<p class="theme__text">
    Политики являются классами, организующими логику авторизации вокруг конкретной модели или ресурса. Например, если ваше приложение является блогом, у вас может быть модель Post и соответствующая политика PostPolicy для авторизации действия пользователя, таких как создание или обновление постов.
Вы можете создать политику, используя artisan команду make:policy. Сформированная политика будет помещена в директорию app/Policies. Если этой директории не существует в приложении, Laravel создаст её:
</p>
<code>
<pre>
    php artisan make:policy PostPolicy
</pre>
</code>
<p class="theme__text">
    Команда make:policy создаст пустой класс политики. Если вы хотите создать класс c базовыми "CRUD" методами уже включенными в политику, можно указать опцию --model при выполнении команды:
</p>
<code>
<pre>
    php artisan make:policy PostPolicy --model=Post
</pre>
</code>
<p class="theme__text">
    Все политики создаются через сервис контейнер Laravel, позволяя указывать в качестве аргументов любые необходимые зависимости в конструкторе политики, чтобы они внедрялись автоматически.
</p>
<h4 class="theme_subtitlex2">Регистрация политик</h4>
<p class="theme__text">
    После создания политики её необходимо зарегистрировать. AuthServiceProvider, входящий в состав свежеустановленного приложения Laravel, содержит свойство policies, которое сопоставляет ваши Eloquent модели соответствующим политикам. Регистрация политики будет указывать Laravel какую политику использовать при авторизации действия для данной моделиl:
</p>
<code>
<pre>
    namespace App\Providers;

use App\Models\Post;
use App\Policies\PostPolicy;
use Illuminate\Foundation\Support\Providers\AuthServiceProvider as ServiceProvider;
use Illuminate\Support\Facades\Gate;

class AuthServiceProvider extends ServiceProvider
{
    /**
     * The policy mappings for the application.
     *
     * @var array
     */
    protected $policies = [
        Post::class => PostPolicy::class,
    ];

    /**
     * Register any application authentication / authorization services.
     *
     * @return void
     */
    public function boot()
    {
        $this->registerPolicies();

        //
    }
}
</pre>
</code>
<h4 class="theme_subtitlex2">Policy Auto-Discovery</h4>
<p class="theme__text">
    Вместо того, чтобы вручную регистрировать политики модели, Laravel может автоматически обнаруживать политики, если модель и политика соответствуют стандартным соглашениям об именах Laravel. В частности, политики должны находиться в каталоге политик в каталоге, который содержит ваши модели, или выше него. Так, например, модели могут быть помещены в каталог app / Models, а политики могут быть размещены в каталоге app / Policies. В этой ситуации Laravel проверит наличие политик в app / Models / Policies, затем app / Policies. Кроме того, имя политики должно совпадать с названием модели и иметь суффикс Policy. Итак, модель User будет соответствовать классу UserPolicy.

Если вы хотите предоставить свою собственную логику обнаружения политики, вы можете зарегистрировать настраиваемый обратный вызов с помощью метода Gate :: guessPolicyNamesUsing. Как правило, этот метод следует вызывать из метода загрузки AuthServiceProvider вашего приложения:
</p>
<code>
<pre>
    use Illuminate\Support\Facades\Gate;

Gate::guessPolicyNamesUsing(function ($modelClass) {
    // return policy class name...
});
</pre>
</code>
<p class="theme__text">
    Любые политики, которые явно отображаются в вашем AuthServiceProvider, будут иметь приоритет над любыми потенциально автоматически обнаруженными политиками.
</p>
<h3 class="theme__subtitle">Написание политик</h3>
<h4 class="theme_subtitlex2">Методы политик</h4>
<p class="theme__text">
    После того, как политика была зарегистрирована, вы можете добавить методы для всех действий, которые она авторизует. Например, давайте определим метод update нашего класса PostPolicy, который определяет может ли данный пользователь User обновить данный экземпляр Post.
Метод update в качестве аргументов получит User и экземпляр Post, и он должен вернуть true или false, что указывает имеет ли пользователь право обновлять данный Post. В данном примере давайте проверим, что id пользователя соответствует user_id поста:
</p>
<code>
<pre>
    namespace App\Policies;

use App\Models\Post;
use App\Models\User;

class PostPolicy
{
    /**
     * Determine if the given post can be updated by the user.
     *
     * @param  \App\Models\User  $user
     * @param  \App\Models\Post  $post
     * @return bool
     */
    public function update(User $user, Post $post)
    {
        return $user->id === $post->user_id;
    }
}
</pre>
</code>
<p class="theme__text">
    Можно продолжать определять дополнительные методы политики по необходимости для различных действий, которые она авторизовывает. Например, вы можете определить методы view или delete для авторизации различных действий над моделью Post, но помните, что можно называть методы своих политик как вам того захочется.
Если вы использовали опцию --model при создании вашей политики из консоли Artisan, она уже будет включать методы для действий view, create, update и delete.
</p>
<h4 class="theme_subtitlex2">Policy Responses</h4>
<p class="theme__text">
    До сих пор мы исследовали только методы политики, возвращающие простые логические значения. Однако иногда вы можете захотеть вернуть более подробный ответ, включая сообщение об ошибке. Для этого вы можете вернуть Illuminate \ Auth \ Access \ Response из вашего метода политики:
</p>
<code>
<pre>
    use Illuminate\Auth\Access\Response;

/**
 * Determine if the given post can be updated by the user.
 *
 * @param  \App\Models\User  $user
 * @param  \App\Models\Post  $post
 * @return \Illuminate\Auth\Access\Response
 */
public function update(User $user, Post $post)
{
    return $user->id === $post->user_id
                ? Response::allow()
                : Response::deny('You do not own this post.');
}
</pre>
</code>
<p class="theme__text">
    При возврате ответа авторизации из вашей политики метод Gate :: allow все равно будет возвращать простое логическое значение; однако вы можете использовать метод Gate :: inspect, чтобы получить полный ответ авторизации, возвращенный шлюзом:
</p>
<code>
<pre>
    $response = Gate::inspect('update', $post);

if ($response->allowed()) {
    // The action is authorized...
} else {
    echo $response->message();
}
</pre>
</code>
<p class="theme__text">
    Конечно, при использовании метода Gate :: authorize для выдачи исключения AuthorizationException, если действие не авторизовано, сообщение об ошибке, предоставленное ответом авторизации, будет передано в ответ HTTP:
</p>
<code>
<pre>
    Gate::authorize('update', $post);

// The action is authorized…
</pre>
</code>
<h4 class="theme_subtitlex2">Методы без моделей</h4>
<p class="theme__text">
    Некоторые методы политики получают только текущего аутентифицированного пользователя, но не экземпляр модели, действие над которой они авторизуют. Такая ситуация чаще всего встречается при авторизации действий create. Например, если вы создаете блог, вы можете проверить, имеет ли пользователь право создавать какие либо посты.
При определении метода политик, которые не получат экземпляр модели, например метода create, следует определить метод таким образом, что он будет ожидать на вход только аутентифицированного пользователя::
</p>
<code>
<pre>
    /**
 * Determine if the given user can create posts.
 *
 * @param  \App\Models\User  $user
 * @return bool
 */
public function create(User $user)
{
    //
}
</pre>
</code>
<h3 class="theme__subtitle">Guest Users</h3>
<p class="theme__text">
    По умолчанию все шлюзы и политики автоматически возвращают false, если входящий HTTP-запрос не был инициирован аутентифицированным пользователем. Однако вы можете разрешить прохождение этих проверок авторизации к вашим шлюзам и политикам, объявив «необязательный» тип-подсказку или предоставив нулевое значение по умолчанию для определения аргумента пользователя:
</p>
<code>
<pre>
    namespace App\Policies;

use App\Models\Post;
use App\Models\User;

class PostPolicy
{
    /**
     * Determine if the given post can be updated by the user.
     *
     * @param  \App\Models\User  $user
     * @param  \App\Models\Post  $post
     * @return bool
     */
    public function update(?User $user, Post $post)
    {
        return optional($user)->id === $post->user_id;
    }
}
</pre>
</code>
<h3 class="theme__subtitle">Фильтры политик</h3>
<p class="theme__text">
    Для определенных пользователей может потребоваться разрешить все действия в рамках данной политики. Для достижения этой цели определите в политике метод before. Метод before будет выполняться перед любыми другими методами политики - это даст вам возможность авторизовать действия до того как будет выполнен конкретный метод политики. Эта функция наиболее часто используется для авторизации выполнения каких-либо действий администратором приложения:
</p>
<code>
<pre>
    public function before($user, $ability)
{
    if ($user->isSuperAdmin()) {
        return true;
    }
}
</pre>
</code>
<p class="theme__text">
    Если вы хотите отклонить все авторизации для пользователя, вы должны вернуть false из метода before. Если возвращается значение NULL, авторизация будет выполняться методом политики.
Метод before класса политики не будет вызываться, если класс не содержит метода с именем, совпадающим с именем проверяемой способности.
</p>
<h3 class="theme__subtitle">Авторизация действий с помощью политик</h3>
<h4 class="theme_subtitlex2">Через модель пользователя</h4>
<p class="theme__text">
    Модель User, которая поставляется с Laravel, включает в себя два полезных метода для авторизации действий: can и cant. Метод can принимает действие, которое вы хотите разрешить, и соответствующую модель. Например, давайте определим имеет ли пользователь право обновлять данную модель Post:
</p>
<code>
<pre>
    if ($user->can('update', $post)) {
        //
    }
</pre>
</code>
<p class="theme__text">
    Если для данной модели зарегистрирована политика, метод can будет автоматически вызывать соответствующую политику и вернет булевое (логическое) значение. Если для данной модели политика не зарегистрирована метод can попытается вызвать замыкание шлюза, соответствующее данному названию действия.
</p>
<h4 class="theme_subtitlex2">Действия которые не требуют моделей</h4>
<p class="theme__text">
    Помните, некоторые действия, такие как create, не могут требовать экземпляр модели. В таких ситуациях, вы можете передать имя класса в метод can. Имя класса будет использоваться для определения того, какие политики использовать при авторизации действия:
</p>
<code>
<pre>
    use App\Models\Post;

if ($user->can('create', Post::class)) {
    // Executes the "create" method on the relevant policy...
}
</pre>
</code>
<h4 class="theme_subtitlex2">Через посредников</h4>
<p class="theme__text">
    Laravel включает в себя посредников, которые могут авторизовать действия до того, как входящий запрос достигнет маршрутов или контроллеров. По умолчанию, в классе App\Http\Kernel посреднику Illuminate\Auth\Middleware\Authorize назначен ключ can. Давайте рассмотрим пример использования посредника can для проверки того, что он может обновлять пост в блоге:
</p>
<code>
<pre>
    use App\Models\Post;

Route::put('/post/{post}', function (Post $post) {
    // The current user may update the post...
})->middleware('can:update,post');
</pre>
</code>
<p class="theme__text">
    В этом примере мы передаем в посредник can два аргумента. Первый - это имя действия, которое мы хотим разрешить, а второй - имя параметра маршрута, который мы хотим передать методу политики. В этом случае, так как мы используем неявную привязку модели, модель Post будет передана методу политики. Если пользователь не имеет права выполнить данное действие, посредником будет сгенерирован HTTP-ответ с кодом 403.
</p>
<h4 class="theme_subtitlex2">Действия которые не требуют моделей</h4>
<p class="theme__text">
    Опять же, некоторые действия, такие как create, не могут требовать экземпляр модели. В таких ситуациях, вы можете передать в посредник имя класса. Имя класса будет использоваться для определения того, какие политики будут использоваться при авторизации действия:
</p>
<code>
<pre>
    Route::post('/post', function () {
        // The current user may create posts...
    })→middleware('can:create,App\Models\Post');
</pre>
</code>
<h4 class="theme_subtitlex2">Через хелперы контроллера</h4>
<p class="theme__text">
    В дополнение к полезным методам, предусмотренным в модели User, Laravel предоставляет еще один полезный метод authorize в любом из контроллеров, которые наследуют базовый класс App\Http\Controllers\Controller. Как и метод can, этот метод принимает имя действия вы хотите разрешить и соответствующую модель. Если действие не разрешено, то метод authorize выбросит исключение Illuminate\Auth\Access\AuthorizationException, которое обработчик исключений Laravel по умолчанию преобразует в ответ HTTP с кодом статуса 403:
</p>
<code>
<pre>
    namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\Request;

class PostController extends Controller
{
    /**
     * Update the given blog post.
     *
     * @param  Request  $request
     * @param  Post  $post
     * @return Response
     * @throws \Illuminate\Auth\Access\AuthorizationException
     */
    public function update(Request $request, Post $post)
    {
        $this->authorize('update', $post);

        // The current user can update the blog post...
    }
}
</pre>
</code>
<h4 class="theme_subtitlex2">Действия которые не требуют моделей</h4>
<p class="theme__text">
    Как обсуждалось ранее, некоторые действия, например create, не могут требовать экземпляр модели. В таких случаях, вы можете передать имя класса в метод authorize. Имя класса будет использоваться для определения того, какие политики будут использоваться при авторизации действия:
</p>
<code>
<pre>
    /**
 * Create a new blog post.
 *
 * @param  Request  $request
 * @return Response
 * @throws \Illuminate\Auth\Access\AuthorizationException
 */
public function create(Request $request)
{
    $this->authorize('create', Post::class);

    // The current user can create blog posts...
}
</pre>
</code>
<h3 class="theme__subtitle">Authorizing Resource Controllers</h3>
<p class="theme__text">
    Если вы используете контроллеры ресурсов, вы можете использовать метод authorizeResource в конструкторе контроллера. Этот метод будет прикреплять соответствующие определения промежуточного программного обеспечения can к методам контроллера ресурсов.

Метод authorizeResource принимает имя класса модели в качестве своего первого аргумента и имя параметра маршрута / запроса, который будет содержать идентификатор модели, в качестве второго аргумента. Вы должны убедиться, что ваш контроллер ресурсов создан с флагом --model, чтобы иметь необходимые сигнатуры методов и подсказки типов:
</p>
<code>
<pre>
    namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\Request;

class PostController extends Controller
{
    public function __construct()
    {
        $this->authorizeResource(Post::class, 'post');
    }
}
</pre>
</code>
<p class="theme__text">Следующие методы контроллера будут сопоставлены с их соответствующим методом политики:</p>
<table>
    <tr>
        <td>Controller Method</td>
        <td>Policy Method</td>
    </tr>
    <tr>
        <td>index</td>
        <td>viewAny</td>
    </tr>
    <tr>
        <td>show</td>
        <td>view</td>
    </tr>
    <tr>
        <td>create</td>
        <td>create</td>
    </tr>
    <tr>
        <td>store</td>
        <td>create</td>
    </tr>
    <tr>
        <td>edit</td>
        <td>update</td>
    </tr>
    <tr>
        <td>update</td>
        <td>update</td>
    </tr>
    <tr>
        <td>destroy</td>
        <td>delete</td>
    </tr>
</table>
<p class="theme__text">
    Вы можете использовать команду make: policy с параметром --model, чтобы быстро создать класс политики для данной модели:
</p>
<code>
<pre>
php artisan make: policy PostPolicy --model = Post.
</pre>
</code>
<h4 class="theme_subtitlex2">Через шаблоны Blade</h4>
<p class="theme__text">
    При написании шаблонов Blade, вам может понадобиться отобразить часть страницы только если пользователь авторизован выполнить данное действие. Например, вы можете показать форму обновления поста в блоге, только если пользователь действительно может обновить пост. В этом случае, вы можете использовать директивы @can и @cannot:
</p>
<code>
<pre>
    @can('update', $post)
    <!-- The Current User Can Update The Post -->
@elsecan('create', App\Models\Post::class)
    <!-- The Current User Can Create New Post -->
@endcan

@cannot('update', $post)
    <!-- The Current User Cannot Update The Post -->
@elsecannot('create', App\Models\Post::class)
    <!-- The Current User Cannot Create A New Post -->
@endcannot
</pre>
</code>
<p class="theme__text">
    Эти директивы являются удобными краткими записями заявлений @if и @unless. Директивы @can и @cannot можно разложить следующим образом:
</p>
<code>
<pre>
    @if (Auth::user()->can('update', $post))
    <!-- The Current User Can Update The Post -->
@endif

@unless (Auth::user()->can('update', $post))
    <!-- The Current User Cannot Update The Post -->
@endunless
</pre>
</code>
<p class="theme__text">
    Вы также можете определить, есть ли у пользователя возможность авторизации из заданного списка способностей. Для этого используйте директиву @canany:
</p>
<code>
<pre>
    @canany(['update', 'view', 'delete'], $post)
    // The current user can update, view, or delete the post
@elsecanany(['create'], \App\Models\Post::class)
    // The current user can create a post
@endcanany
</pre>
</code>
<h4 class="theme_subtitlex2">Действия которые не требуют моделей</h4>
<p class="theme__text">
    Как и большинство других методов авторизации, вы можете передать имя класса директивам @can и @cannot, если для действия не требуется экземпляр модели:
</p>
<code>
<pre>
    @can('create', App\Models\Post::class)
    <!-- The Current User Can Create Posts -->
@endcan

@cannot('create', App\Models\Post::class)
    <!-- The Current User Can't Create Posts -->
@endcannot
</pre>
</code>
<h3 class="theme__subtitle">Supplying Additional Context</h3>
<p class="theme__text">
    При авторизации действий с использованием политик вы можете передать массив в качестве второго аргумента различным функциям авторизации и помощникам. Первый элемент в массиве будет использоваться для определения того, какая политика должна быть вызвана, в то время как остальные элементы массива передаются как параметры методу политики и могут использоваться для дополнительного контекста при принятии решений об авторизации. Например, рассмотрим следующее определение метода PostPolicy, которое содержит дополнительный параметр $ category:
</p>
<code>
<pre>
    /**
 * Determine if the given post can be updated by the user.
 *
 * @param  \App\Models\User  $user
 * @param  \App\Models\  $post
 * @param  int  $category
 * @return bool
 */
public function update(User $user, Post $post, int $category)
{
    return $user->id === $post->user_id &&
           $category > 3;
}
</pre>
</code>
<p class="theme__text">
    При попытке определить, может ли аутентифицированный пользователь обновить данное сообщение, мы можем вызвать этот метод политики следующим образом:
</p>
<code>
<pre>
    /**
 * Update the given blog post.
 *
 * @param  Request  $request
 * @param  Post  $post
 * @return Response
 * @throws \Illuminate\Auth\Access\AuthorizationException
 */
public function update(Request $request, Post $post)
{
    $this->authorize('update', [$post, $request->input('category')]);

    // The current user can update the blog post...
}
</pre>
</code>
</div>
<div class="theme">
    <h2 class="theme__title">Email Verification</h2>
    <p class="theme__text">
        Многие веб-приложения требуют, чтобы пользователи проверяли свои адреса электронной почты перед использованием приложения. Вместо того, чтобы заставлять вас повторно реализовывать это в каждом приложении, Laravel предоставляет удобные методы для отправки и проверки запросов на проверку электронной почты.

Хотите быстро начать работу? Установите Laravel Jetstream в новом приложении Laravel. После миграции базы данных перейдите в браузере по адресу / register или любому другому URL-адресу, назначенному вашему приложению. Jetstream позаботится о построении всей вашей системы аутентификации, включая поддержку проверки электронной почты!
    </p>
    <h3 class="theme__subtitle">Model Preparation</h3>
    <p class="theme__text">
        Для начала убедитесь, что ваша модель App \ Models \ User реализует контракт Illuminate \ Contracts \ Auth \ MustVerifyEmail:
    </p>
    <code>
    <pre>
        namespace App\Models;

use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;

class User extends Authenticatable implements MustVerifyEmail
{
    use Notifiable;

    // ...
}
</pre>
</code>
<p class="theme__text">
    Как только этот интерфейс будет добавлен к вашей модели, новым зарегистрированным пользователям будет автоматически отправлено электронное письмо со ссылкой для подтверждения адреса электронной почты. Как вы можете видеть, изучив свой EventServiceProvider, Laravel уже содержит прослушиватель SendEmailVerificationNotification, который прикреплен к событию Illuminate \ Auth \ Events \ Registered.

Если вы вручную реализуете регистрацию в своем приложении вместо использования Laravel Jetstream, вы должны убедиться, что отправляете событие Illuminate \ Auth \ Events \ Registered после успешной регистрации пользователя:

</p>
<code>
<pre>
    use Illuminate\Auth\Events\Registered;
    event(new Registered($user));
</pre>
</code>
<h3 class="theme__subtitle">Database Preparation</h3>
<p class="theme__text">
    Затем ваша таблица пользователей должна содержать столбец email_verified_at для хранения даты и времени, когда адрес электронной почты был подтвержден. По умолчанию миграция таблицы пользователей, включенная в структуру Laravel, уже включает этот столбец. Итак, все, что вам нужно сделать, это запустить миграцию базы данных:
</p>
<code>
<pre>
    php artisan migrate
</pre>
</code>
<h3 class="theme__subtitle">Routing</h3>
<p class="theme__text">
    Чтобы правильно реализовать проверку электронной почты, необходимо определить три маршрута. Во-первых, потребуется маршрут для отображения уведомления пользователю о том, что он должен щелкнуть ссылку подтверждения электронной почты в проверочном письме, которое Laravel отправил им после регистрации. Во-вторых, потребуется маршрут для обработки запросов, сгенерированных, когда пользователь щелкает ссылку подтверждения электронной почты в электронном письме. В-третьих, потребуется маршрут для повторной отправки проверочной ссылки, если пользователь случайно потеряет первую.
</p>
<h3 class="theme__subtitle">The Email Verification Notice</h3>
<p class="theme__text">
    Как упоминалось ранее, должен быть определен маршрут, который будет возвращать представление, инструктирующее пользователя щелкнуть ссылку подтверждения электронной почты, которая была отправлена им по электронной почте от Laravel. Это представление будет отображаться для пользователей, когда они попытаются получить доступ к другим частям приложения без предварительной проверки своего адреса электронной почты. Помните, что ссылка автоматически отправляется пользователю по электронной почте, если ваша модель App \ Models \ User реализует интерфейс MustVerifyEmail:
</p>
<code>
<pre>
    Route::get('/email/verify', function () {
        return view('auth.verify-email');
    })->middleware(['auth'])->name('verification.notice');
</pre>
</code>
<p class="theme__text">
    Маршрут, который возвращает уведомление о подтверждении электронной почты, должен называться verify.notice. Важно, чтобы маршруту было присвоено это точное имя, поскольку проверенное промежуточное ПО, включенное в Laravel, будет автоматически перенаправлять на это имя маршрута, если пользователь не подтвердил свой адрес электронной почты.

При ручном внедрении проверки электронной почты вы должны сами определить содержимое просмотра уведомления о проверке. Если вам нужны строительные леса, включающие все необходимые представления для аутентификации и проверки, попробуйте Laravel Jetstream.
</p>
<h3 class="theme__subtitle">The Email Verification Handler</h3>
<p class="theme__text">
    Затем нам нужен маршрут, который будет обрабатывать запросы, сгенерированные, когда пользователь щелкает ссылку подтверждения электронной почты, которая была отправлена ему по электронной почте. Этот маршрут должен называться verify.verify и ему должны быть назначены промежуточное ПО для аутентификации и подписи:
</p>
<code>
<pre>
    use Illuminate\Foundation\Auth\EmailVerificationRequest;
use Illuminate\Http\Request;

Route::get('/email/verify/{id}/{hash}', function (EmailVerificationRequest $request) {
    $request->fulfill();

    return redirect('/home');
})->middleware(['auth', 'signed'])->name('verification.verify');
</pre>
</code>
<p class="theme__text">
    Прежде чем двигаться дальше, давайте подробнее рассмотрим этот маршрут. Во-первых, вы заметите, что мы используем тип запроса EmailVerificationRequest вместо типичного экземпляра Illuminate \ Http \ Request. EmailVerificationRequest - это запрос формы, включенный в Laravel. Этот запрос позаботится об автоматической проверке идентификатора запроса и параметров хэша.

Далее мы можем перейти непосредственно к вызову метода execute по запросу. Этот метод вызовет метод markEmailAsVerified для аутентифицированного пользователя и отправит событие Illuminate \ Auth \ Events \ Verified. Метод markEmailAsVerified доступен для модели App \ Models \ User по умолчанию через базовый класс Illuminate \ Foundation \ Auth \ User. После подтверждения адреса электронной почты пользователя вы можете перенаправить его куда хотите.
</p>
<h3 class="theme__subtitle">Resending The Verification Email</h3>
<p class="theme__text">
    Иногда пользователь может потерять или случайно удалить письмо с подтверждением адреса электронной почты. Чтобы приспособиться к этому, вы можете определить маршрут, позволяющий пользователю запрашивать повторную отправку проверочного письма. Затем вы можете сделать запрос по этому маршруту, разместив простую кнопку отправки формы в окне уведомления о проверке:
</p>
<code>
<pre>
    use Illuminate\Http\Request;

Route::post('/email/verification-notification', function (Request $request) {
    $request->user()->sendEmailVerificationNotification();

    return back()->with('status', 'verification-link-sent');
})->middleware(['auth', 'throttle:6,1'])->name('verification.send');
</pre>
</code>
<h3 class="theme__subtitle">Protecting Routes</h3>
<p class="theme__text">
    Промежуточное ПО маршрута может использоваться только для того, чтобы разрешить доступ к заданному маршруту только проверенным пользователям. Laravel поставляется с проверенным промежуточным программным обеспечением, которое ссылается на класс Illuminate \ Auth \ Middleware \ EnsureEmailIsVerified. Поскольку это промежуточное ПО уже зарегистрировано в HTTP-ядре вашего приложения, все, что вам нужно сделать, это прикрепить промежуточное ПО к определению маршрута:
</p>
<code>
<pre>
    Route::get('profile', function () {
        // Only verified users may enter...
    })->middleware('verified');
</pre>
</code>
<p class="theme__text">
    Если непроверенный пользователь попытается получить доступ к маршруту, которому назначено это промежуточное ПО, он будет автоматически перенаправлен на именованный маршрут verify.notice.
</p>
<h4 class="theme_subtitlex2">Events</h4>
<p class="theme__text">
    При использовании Laravel Jetstream Laravel отправляет события в процессе проверки электронной почты. Если вы вручную обрабатываете проверку электронной почты для своего приложения, вы можете вручную отправлять эти события после завершения проверки. Вы можете прикрепить слушателей к этим событиям в своем EventServiceProvider:
</p>
<code>
<pre>
    /**
 * The event listener mappings for the application.
 *
 * @var array
 */
protected $listen = [
    'Illuminate\Auth\Events\Verified' => [
        'App\Listeners\LogVerifiedUser',
    ],
];
</pre>
</code>
</div>
<div class="theme">
<h1 class="themes__title">Encryption</h1>
<p class="theme__text">
    Шифратор Laravel использует OpenSSL для шифрования по алгоритмам AES-256 и AES-128. Настоятельно призываем вас использовать встроенные в Laravel возможности шифрования и не пытаться применять свои "самодельные" алгоритмы шифрования. Все шифрованные значения подписаны кодом аутентификации сообщения (MAC) для предотвращения любых изменений в зашифрованной строке.
</p>
<h3 class="theme__subtitle">Настройка</h3>
<p class="theme__text">
    Перед использованием шифрования Laravel обязательно задайте ключ key в конфиге config/app.php. Для этого вам надо использовать команду php artisan key:generate, которая использует надёжный генератор случайных чисел для создания вашего ключа. Без этого ключа все зашифрованные Laravel значения не будут безопасными.
</p>
<h3 class="theme__subtitle">Использование шифратора</h3>
<h4 class="theme_subtitlex2">Шифрование значения</h4>
<p class="theme__text">
    Вы можете зашифровать значение с помощью хелпера encrypt. Все значения шифруются с помощью OpenSSL и шифра AES-256-CBC. Более того, все шифрованные значения подписаны кодом аутентификации сообщения (MAC) для обнаружения любых изменений в зашифрованной строке:
</p>
<code>
<pre>
    namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Crypt;

class UserController extends Controller
{
    /**
     * Store a secret message for the user.
     *
     * @param  Request  $request
     * @param  int  $id
     * @return Response
     */
    public function storeSecret(Request $request, $id)
    {
        $user = User::findOrFail($id);

        $user->fill([
            'secret' => Crypt::encryptString($request->secret),
        ])->save();
    }
}
</pre>
</code>
<h4 class="theme_subtitlex2">Расшифровка значения</h4>
<p class="theme__text">
    Вы можете расшифровать значение при помощи хелпера decrypt. Если значение не может быть корректно расшифровано, например, при неверном MAC, будет выброшено исключение Illuminate\Contracts\Encryption\DecryptException:
</p>
<code>
<pre>
    use Illuminate\Contracts\Encryption\DecryptException;
use Illuminate\Support\Facades\Crypt;

try {
    $decrypted = Crypt::decryptString($encryptedValue);
} catch (DecryptException $e) {
    //
}
</pre>
</code>
</div>
<div class="theme">
<h2 class="theme__title">Hashing</h2>
<p class="theme__text">
    Фасад Hash в Laravel обеспечивает надёжное Bcrypt и Argon2  хеширование для хранения паролей пользователей. Если вы используете шаблон аутентификации Laravel Jetstream, по умолчанию для регистрации и аутентификации будет использоваться Bcrypt.

Bcrypt - отличный выбор для хеширования паролей, потому что его «рабочий фактор» регулируется, а это означает, что время, необходимое для генерации хеш-кода, может быть увеличено по мере увеличения мощности оборудования.
</p>
<h3 class="theme__subtitle">
    Configuration
</h3>
<p class="theme__text">
    Драйвер хеширования по умолчанию для вашего приложения настраивается в файле конфигурации config / hashing.php. В настоящее время поддерживается три драйвера: Bcrypt и Argon2 (варианты Argon2i и Argon2id).

Для драйвера Argon2i требуется PHP 7.2.0 или выше, а для драйвера Argon2id требуется PHP 7.3.0 или выше.
</p>
<h3 class="theme__subtitle">
    Basic Usage
</h3>
<p class="theme__text">
    Вы можете хешировать пароль, вызвав метод make на фасаде Hash:
</p>
<code>
<pre>
    namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;

class UpdatePasswordController extends Controller
{
    /**
     * Update the password for the user.
     *
     * @param  Request  $request
     * @return Response
     */
    public function update(Request $request)
    {
        // Validate the new password length...

        $request->user()->fill([
            'password' => Hash::make($request->newPassword)
        ])->save();
    }
}
</pre>
</code>
<h3 class="theme__subtitle">Adjusting The Bcrypt Work Factor</h3>
<p class="theme__text">
    Если вы используете алгоритм Bcrypt, метод make позволяет вам управлять коэффициентом работы алгоритма с помощью параметра раундов; однако значение по умолчанию приемлемо для большинства приложений:
</p>
<code>
<pre>
    $hashed = Hash::make('password', [
    'rounds' => 12,
]);
</pre>
</code>
<h3 class="theme__subtitle">Adjusting The Argon2 Work Factor</h3>
<p class="theme__text">
    Если вы используете алгоритм Argon2, метод make позволяет вам управлять коэффициентом работы алгоритма, используя параметры памяти, времени и потоков; однако для большинства приложений приемлемы значения по умолчанию:
</p>
<code>
<pre>
    $hashed = Hash::make('password', [
    'memory' => 1024,
    'time' => 2,
    'threads' => 2,
]);

</pre>
</code>
<p class="theme__text">
    For more information on these options, check out the official PHP documentation.
</p>
<h3 class="theme__subtitle">Verifying A Password Against A Hash</h3>
<p class="theme__text">
    Метод проверки позволяет проверить, соответствует ли заданная текстовая строка заданному хешу:
</p>
<code>
<pre>
    if (Hash::check('plain-text', $hashedPassword)) {
        // The passwords match...
    }
</pre>
</code>
<h3 class="theme__subtitle">Checking If A Password Needs To Be Rehashed</h3>
<p class="theme__text">
Функция needsRehash позволяет определить, изменился ли рабочий коэффициент, используемый хешером, с момента хеширования пароля:
</p>
<code>
<pre>
    if (Hash::needsRehash($hashed)) {
        $hashed = Hash::make('plain-text');
    }
</pre>
</code>
</div>
<div class="theme">
<h2 class="theme__title">Resetting Passwords</h2>
<p class="theme__text">
    Большинство веб-приложений предоставляют пользователям возможность сбросить забытые пароли. Вместо того, чтобы заставлять вас повторно реализовывать это в каждом приложении, Laravel предоставляет удобные методы для отправки напоминаний о пароле и выполнения сброса пароля.

Хотите быстро начать работу? Установите Laravel Jetstream в новом приложении Laravel. После миграции базы данных перейдите в браузере по адресу / register или любому другому URL-адресу, назначенному вашему приложению. Jetstream позаботится о построении всей вашей системы аутентификации, включая сброс паролей!
</p>
<h3 class="theme__subtitle">Model Preparation</h3>
<p class="theme__text">
    Перед использованием функций сброса пароля Laravel ваша модель App \ Models \ User должна использовать трейт Illuminate \ Notifications \ Notifiable. Обычно эта черта автоматически включается в модель по умолчанию App \ Models \ User, которая включена в Laravel.

Затем убедитесь, что ваша модель App \ Models \ User реализует контракт Illuminate \ Contracts \ Auth \ CanResetPassword. Модель App \ Models \ User, включенная в структуру, уже реализует этот интерфейс и использует черту Illuminate \ Auth \ Passwords \ CanResetPassword для включения методов, необходимых для реализации интерфейса.
</p>
<h3 class="theme__subtitle">
    Database Preparation
</h3>
<p class="theme__text">
    Необходимо создать таблицу для хранения токенов сброса пароля вашего приложения. Миграция для этой таблицы включена в установку Laravel по умолчанию, поэтому вам нужно только перенести вашу базу данных, чтобы создать эту таблицу:


</p>
<code>
<pre>
    php artisan migrate
</pre>
</code>
<h3 class="theme__subtitle">Routing</h3>
<p class="theme__text">
    Чтобы правильно реализовать поддержку, позволяющую пользователям сбрасывать свои пароли, нам нужно будет определить несколько маршрутов. Во-первых, нам понадобится пара маршрутов для обработки, позволяющая пользователю запрашивать ссылку для сброса пароля через свой адрес электронной почты. Во-вторых, нам понадобится пара маршрутов для обработки фактического сброса пароля после того, как пользователь перейдет по ссылке для сброса пароля, отправленной ему по электронной почте.
</p>
<h3 class="theme__subtitle">Requesting The Password Reset Link</h3>
<h4 class="theme_subtitlex2">The Password Reset Link Request Form</h4>
<p class="theme__text">
    Сначала мы определим маршруты, необходимые для запроса ссылок для сброса пароля. Для начала мы определим маршрут, который возвращает представление с формой запроса ссылки для сброса пароля:
</p>
<code>
<pre>
    Route::get('/forgot-password', function () {
        return view('auth.forgot-password');
    })->middleware(['guest'])->name('password.request');
</pre>
</code>
<p class="theme__text">
    Представление, возвращаемое этим маршрутом, должно иметь форму, содержащую поле электронной почты, которое позволит пользователю запрашивать ссылку для сброса пароля для данного адреса электронной почты.
</p>
<h4 class="theme_subtitlex2">
    Handling The Form Submission
</h4>
<p class="theme__text">
    Затем мы определим маршрут, который будет обрабатывать запрос формы из представления «забыл пароль». Этот маршрут будет отвечать за проверку адреса электронной почты и отправку запроса на сброс пароля соответствующему пользователю:
</p>
<code>
<pre>
    use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;

Route::post('/forgot-password', function (Request $request) {
    $request->validate(['email' => 'required|email']);

    $status = Password::sendResetLink(
        $request->only('email')
    );

    return $status === Password::RESET_LINK_SENT
                ? back()->with(['status' => __($status)])
                : back()->withErrors(['email' => __($status)]);
})->middleware(['guest'])->name('password.email');
</pre>
</code>
<p class="theme__text">
    Прежде чем двигаться дальше, давайте рассмотрим этот маршрут более подробно. Сначала проверяется атрибут электронной почты запроса. Затем мы будем использовать встроенный в Laravel «брокер паролей» (через фасад пароля), чтобы отправить пользователю ссылку для сброса пароля. Брокер паролей позаботится о получении пользователя по заданному полю (в данном случае по адресу электронной почты) и отправит пользователю ссылку для сброса пароля через встроенную систему уведомлений Laravel.

Метод sendResetLink возвращает ярлык "status". Этот статус может быть переведен с помощью помощников по локализации Laravel, чтобы отобразить удобное для пользователя сообщение о статусе его запроса. Перевод статуса сброса пароля определяется языковым файлом resources / lang / {lang} /passwords.php вашего приложения. Запись для каждого возможного значения ярлыка состояния находится в языковом файле паролей.

При выполнении сброса пароля вручную вы должны сами определять содержимое представлений и маршрутов. Если вам нужны строительные леса, включающие всю необходимую логику аутентификации и проверки, попробуйте Laravel Jetstream.
</p>
<h3 class="theme__subtitle">
    Resetting The Password

</h3>
<h4 class="theme_subtitlex2">The Password Reset Form</h4>
<p class="theme__text">
    Затем мы определим маршруты, необходимые для фактического сброса пароля после того, как пользователь щелкнет ссылку для сброса пароля, отправленную ему по электронной почте, и предоставит новый пароль. Во-первых, давайте определим маршрут, который будет отображать форму сброса пароля, которая отображается, когда пользователь щелкает ссылку сброса пароля. Этот маршрут получит параметр токена, который мы будем использовать позже для проверки запроса на сброс пароля:
</p>
<code>
<pre>
    Route::get('/reset-password/{token}', function ($token) {
        return view('auth.reset-password', ['token' => $token]);
    })->middleware(['guest'])->name('password.reset');
</pre>
</code>
<p class="theme__text">
    Представление, возвращаемое этим маршрутом, должно иметь форму, содержащую поле электронной почты, поле пароля, поле password_confirmation и поле скрытого токена, которое должно содержать значение секретного токена, полученного нашим маршрутом.
</p>
<h4 class="theme_subtitlex2">Handling The Form Submission</h4>
<p class="theme__text">
    Конечно, нам нужно определить маршрут для фактической обработки отправки формы сброса пароля. Этот маршрут будет отвечать за проверку входящего запроса и обновление пароля пользователя в базе данных:
</p>
<code>
<pre>
    use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;

Route::post('/reset-password', function (Request $request) {
    $request->validate([
        'token' => 'required',
        'email' => 'required|email',
        'password' => 'required|min:8|confirmed',
    ]);

    $status = Password::reset(
        $request->only('email', 'password', 'password_confirmation', 'token'),
        function ($user, $password) use ($request) {
            $user->forceFill([
                'password' => Hash::make($password)
            ])->save();

            $user->setRememberToken(Str::random(60));

            event(new PasswordReset($user));
        }
    );

    return $status == Password::PASSWORD_RESET
                ? redirect()->route('login')->with('status', __($status))
                : back()->withErrors(['email' => __($status)]);
})->middleware(['guest'])->name('password.update');
</pre>
</code>
<p class="theme__text">
    Прежде чем двигаться дальше, давайте рассмотрим этот маршрут более подробно. Сначала проверяются атрибуты токена, адреса электронной почты и пароля запроса. Затем мы будем использовать встроенный в Laravel «брокер паролей» (через фасад пароля) для проверки учетных данных запроса сброса пароля.

Если токен, адрес электронной почты и пароль, предоставленные брокеру паролей, действительны, будет вызываться Closure, переданное методу сброса. В этом замыкании, которое получает экземпляр пользователя и пароль в виде обычного текста, мы можем обновить пароль пользователя в базе данных.

Метод сброса возвращает ярлык "статуса". Этот статус может быть переведен с помощью помощников по локализации Laravel, чтобы отобразить удобное для пользователя сообщение о статусе его запроса. Перевод статуса сброса пароля определяется языковым файлом resources / lang / {lang} /passwords.php вашего приложения. Запись для каждого возможного значения ярлыка состояния находится в языковом файле паролей.
</p>
<h3 class="theme__subtitle">Customization</h3>
<h4 class="theme_subtitlex2">Reset Link Customization</h4>
<p class="theme__text">
    Вы можете настроить URL-адрес ссылки для сброса пароля с помощью метода createUrlUsing, предоставляемого классом уведомлений ResetPassword. Этот метод принимает Closure, который получает пользовательский экземпляр, получающий уведомление, а также токен ссылки для сброса пароля. Как правило, этот метод следует вызывать из метода загрузки поставщика услуг:
</p>
<code>
<pre>
    use Illuminate\Auth\Notifications\ResetPassword;

/**
 * Bootstrap any application services.
 *
 * @return void
 */
public function boot()
{
    ResetPassword::createUrlUsing(function ($notifiable, string $token) {
        return 'https://example.com/auth/reset-password?token='.$token;
    });
}
</pre>
</code>
<h4 class="theme_subtitlex2">Reset Email Customization</h4>
<p class="theme__text">
    Вы можете легко изменить класс уведомлений, используемый для отправки пользователю ссылки для сброса пароля. Для начала переопределите метод sendPasswordResetNotification в своей модели User. В этом методе вы можете отправить уведомление, используя любой выбранный вами класс уведомлений. Токен сброса пароля $ - это первый аргумент, полученный методом:
</p>
<code>
<pre>
    /**
 * Send the password reset notification.
 *
 * @param  string  $token
 * @return void
 */
public function sendPasswordResetNotification($token)
{
    $this->notify(new ResetPasswordNotification($token));
}
</pre>
</code>





</div>
@endsection





<h1 class="themes__title"></h1>
<h2 class="theme__title"></h2>
<h3 class="theme__subtitle"></h3>
<h4 class="theme_subtitlex2"></h4>
<p class="theme__text"></p>
<code>
<pre>
</pre>
</code>
<p class="theme__text"></p>
<code>
<pre>
</pre>
</code>
