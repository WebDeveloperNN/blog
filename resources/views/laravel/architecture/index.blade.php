@extends('layouts.mainLayout')

<div class="youtube content">
    <div>
        Архитектуру нужно знать, чтобы добавлять свой функционал. Например:
        1) Вы можете создать папку App\Services\DataCheck.php и в этом файле будет реализован class DataCheck, который проверяют дату (только не забудьте указать пространство имен, в данном случае App\Services, так как мы так папку назвали).
        // code
        namespace App\Services;
        class DataCheck {
            public function isValid() {
                ///
            }
        }
        2) Так в первом пункте мы написали сервис, который мы хотим использовать в нашем приложение (сервис, тут имеется в виду функционал, скрипт и так далее).Как его задействовать в нашем проекте?
        // SomeController.php
        use App\Services\DataCheck;
        class SomeController extends Controller {
            public function index() {
                $test = new DataCheck();
                $test->isValid();
            }
        }
        Заметим, что работая в Laravel мы привыкли использовать статические методы:
        // SomeController.php
        use App\Services\DataCheck;
        class SomeController extends Controller {
            public function index() {
                // $test = new DataCheck();
                // $test->isValid();
                DataCheck::isValid();
            }
        }
        Хорошо. Как это реализовать?
        3) Познакомися с сервис-контейнером.
        Сервис-контейнер - это хранилище объектов классов, которые вам доступны при закузки. Сервис-контейнер хранилище функционала, который есть у вас в приложение. Приложение - это и есть сервис-контейнер.

        То есть сервис контейнер - это и есть само приложение, в нем хранятся объекты классов, которые и предоставляют функционал для приложения. В нем (объекта класса сервис-контейнер) хранятся все загруженные сервисы (весь функционал/объекты классов сервисов), которые доступны для вас.

        Грубо говоря, сервис-контейнер - объект, в свойствах которого содержаться объекты других классов, в которых содержится некий функционал и к которому вы можете обращаться. (это и есть внерение? А что такое lot).

        Хорошо. Каким образом этот функционал попадает в сервис-контейнер? Как его туда добавить?
        4) Познакомися с сервис-провайдерами.
        Сервис-провайдер - поставщик услуг, с помощью которого реализуется связь между каким-то функционалом и сервис-контейнером. Он не содержит в себе функционал, он связывает некий функционал (обычно это ваш кастомный класс, как например DataCheck) с сервис-контейнером.
        Можно скзаать что он добавляет функционал в сервис-контейнер/приложение.

        В каталоге config/app.php в поле 'providerd', содержится список тех сервис-провайдеров, которые по-умолчанию загружаются с загрузкой фреймворка. Каждый из этих сервис-провайдеров добавляет функционал в сервис-контейнер/приложение, добавляет определенные объекты в сервис-контейнер, которые содекржат необходимый функционал.

        Создание пройвайдера.
        Он просто создал файл в provides и назвал его DataCheckServiceProvider.php.
        // App\Providers\DataCheckServiceProvider.php
        namespace App\Providers;
        use Illimunate\Support\ServiceProvider;
        class DataCheckServiceProvider extends ServiceProvider {
            // Привязываем кастомные (пользовательские) классы, которые содержат функционал к сервис-контейнеру.
            // То есть тут мы добавляем функционал в сервис-контейнер
            public function register() {
                // $this->app - сервис-контейнер/приложение (непосредственно хранилище)
                // bind() - реализует связь между определенным классом и сервис-провайдером. Связываем ваш класс с сервис провайдером. Первым параметром имя свойства, в котором хранитя ваш класс в сервис контейнере. Вторым параметром объект, который будет размещен в сервис-пройвадере.
                $this->app->bind('dataCheck', 'App\Servises\DateCheck');
                // App\Servises\DateCheck - здесь кастомный класс хранится.
                // dataCheck - названия для свойства, которое бужет хранить объект класса DateCheck.
            }
        }
        Но, данный сервис-провайдер он будет не доступен. Поэтому если его нужно загрузить сразу при загрузке framework, то добавте его в config/app.php в массив providers.
        'providers' => [
            // ,
            App\Providers\DataCheckServiceProvider::class
        ]

        Хорошо. Понятно теперь как добвить функционал в приложение (кстати, теперь чем отличается от того как было в 1 пункте реализовано? теперь можно не подключать или теперь класс можно не создавать? ведь объект уже хранится в сервис-контейнере. Вообщем что это нам дало?), но как сделать чтобы мы обращались к статическим методам?
        5) Познакомися с Фасад.
        Фасад - это класс-посредник, который предоставляет статический интерфейс для определенных объектов классов, которые хранятся в сервис-контейнере. Фасад предоставляет статический интерфейс. Статический интерфейс - это вызов статического метода.

        И что тут такого?
        У нас в классу DataCheck не описан статический метод. isValid() не является статическим методом. Но при этом фасад предоставляет статический интерфейс.

        То есть фасады - классы посредники, которые предоставляют доступ к другим классам которые уже добавлены в сервис контейнер. То есть вы обращается не напрямую к классу, который находится в сервис контейнер а через фасад.

        Создание фасадов.
        Он создал папку Facades. И дал названи DateService.
        // app\Facades\DataService.php
        namespace app\Facades;
        use Illimunate\Support\Facades\Facade;
        class DateService extends Facade {
            // вернуть строковое имя, ключ привязки объекта к сервис-контейнеру.
            // То есть фасад должен вернуть имя свойства, которая мы указали в сервис-провайдере. Имя свойства, которое будет хранить объект кастомного класса. Имя свойства сервис-контейнера, где храниться объект кастомного класса.ы
            protected static function getFacadeAccessor() {
                return 'dataCheck';
            }
        }
        Теперь нужно зарегистрировать фасад, сделать это можно в config/app.php массив allies (псведонимы, связывают какие-то названия с конкретными фасадами. По факту это имя фасада, ну или алиас фасада):
        'alies' => [
            //,
            'DateService' => App\Facades\DateService::class
        ]
        То есть тут вы указываете по какому имени можно обратится к вашему кастомному классу с помощью "статического" методов. Ну бля короче, тут это:
        DateService:: вот так будет

        6) Теперь в контролере можно сделать так:
        use DataService;
        class controller {
            DateService::isValid();
        }

        Видео:
        https://www.youtube.com/watch?v=Ow0MrDTJ-Qo&t=934s

        Итог (что я понял):
    </div>
    <div>
        Сервис-провайдеры (поставщики услуг) - классы, предназначенные для первоначальной загрузки приложения. То естьт загрузки необходимых элементов или сервисов функционал которых будет использовать для проекта.
        Первоначальная загрузка подразумевает регистрацию классов (сервисов) в сервис контейнере, то есть глобальном объекте app. А также обработчиков и так далее.....

        В методе register можно только регистрировать свои собственные классы в сервис контейнере. Обработчики и так далее в данном методе регистрировать нельзя, так как для них есть специальный метод, который называется boot.

        Как создать сервис провайдер?
        php artisan make:provider NameServiceProvider

        Как приложение запускается app объект, то есть сервис-контейнер опрашивает все доступные сервис-провайдеры и вызывает наисполнение метод register() каждого сервис-провайдера, таким образом в сервис контейнер регистрируются все необходимые сервисы.
        Для регистрации класса в сервис-провайдере вы можете использовать метод bind():
        // App\Providers\NameServiceProvider
        {
            public function register() {
                $this->app->bind('яцейка в сервис контейнере', function() {
                    return ...
                });
            }
        }
        bind() - служит для привязки определенной анонимной функции к заданной ячейки сервис-провайдера (ну наверное лучше скзаать определенного функционала??? можно например поместить в сервис провайдер функциюю hello() {alert('hello')})

        Сервис - класс, который предоставляет опрделенный функционал.

        Далее нам нужно зарегистрировать сервис провайдер в providers[]

        Сервис-контейнер - это класс, который хранит информацию о зарегистрированных сервисах (которые достпуны).

        Кстати, он в методе bind указал где хранится интерфейс, а не имя: bind('App\Helpers\Contracts\SaveStr', ....); А ну скорее всего \это ничего не значит просто ячейка будет так называться.
        Я понял: он это так назвал чтобы можно было сделать внедрение зависимости. Он сказал, что если нет фасада и чтобы работало внедрение зависмости:
        use App\Helpers\Contracts\SaveStr;
        store(SaveStr $savestr) {}
        Нужно указывать так: App\Helpers\Contracts\SaveStr
        Если же мы делаем фасад, то можно сократить до SaveStr.
        Дословно (13;32 https://www.youtube.com/watch?v=qWDcMfJ_7oE&list=PL9ogRqeIEMzntnGiOj0tHu0o2ldxWWtJR&index=38): пока у вас нет фасада, то в сервис-провайдере осуществляете регистрацию конкретного сервиса в сервис контейнер необходимо указываит в виде ключа полное квалификацуионно имя. Тогда вы можете использовать внедрение зависимостей и make().
        Ну вообщшем это надо понять. Но тут езе нужно знать про внедрение зависмостей, use, namespace.


        Когда вы зарегистрировали класс в сервис-контейнере то уже не нужно создавать его использую new - не нужно создать объект. Но тогда каким образом получить доступ к объектам классов которые хранятся в ячейках сервис-првоайдера:
        use App;
        App::make('App\Helpers\Contracts\SaveStr'); - получаем объект реализации конктерного класса.
        // App - фасад сервис-провайдера
        // make() - позволяет получить доступ к ячейкам сервис-контейнера.

        Также в сервис контейнер в сервис провайдере можно добавить уже существующий объект:
        public function register() {
            // instance() - позволяет для определенного строкового ключа зарегистрировать некий объект.
            $obj = new SaveFile()
            $this->app->instance('App\Helpers\Contracts\SaveStr', $obj)
        }

        Также вы можете получить доступ к уже зарегистрированным провайдерам так:
        public function register() {
            $this->app['App\Helpers\Contracts\SaveStr'];
            // ну или make
            $this->app->make('App\Helpers\Contracts\SaveStr');
        }

        Хелпер для отладки: dd() - do and die

        Когда будет загружена вся информация в сервис-контейнер у каждого сервис-провайдера будет вызван метод boot(). То есть в этом методе уже можно использовать все объекты из сервис контейнера.

        Мы рассмотрели bind(), но часто необходимо чтобы объект класс создавался только 1 раз, а далее при обращение к тому или иному классу, разрешался раннее созданный объект.То есть это реализация шаблона проектирования singleton, то есть паттерна синглтон, так как мы используем фреймворк нам не нужно прописыфвать код этого паттерна, так как есть метод singleton(). Объект класса будет создан только 1 раз, а далее вы будете получать только ранне созданный объект.


        Как создать свой фасад?
        Фасады предоставлояют статический интерфейс для доступа к объектам классов зарегестрированных в сервис-контейнере.
        namespace App\Helpers\Facades;
        class OurFacade extends Facade {
            // этот класс нужно обязательно переопределить
            protected static function getFacadeAccessor() {
                return 'saveStr';
            }
        }
        Функция getFacadeAccessor возаращает строковый ключ, которое используется для доступа к ячейчки сервис контейнера и соотвественно к классу котороый соотвествует этой ячейки.
        Далее как мы указали имя ячейки, нам нужно дать имя для фасада, чтобы не прописывать его каждый раз полностью (App\Helpers\Facades\SaveStr), поэтому зададим alies:
        alies => [
            'saveStr' => 'App\Helpers\Facades\SaveStr::class'
        ]
        echo "# f" >> README.md
        git init
        git add README.md
        git commit -m "first commit"
        git branch -M main
        git remote add origin https://github.com/WebDeveloperNN/f.git
        git push -u origin main

        Видео:
        плейлист: https://www.youtube.com/watch?v=nWo5vHkOyBk&list=PL9ogRqeIEMzntnGiOj0tHu0o2ldxWWtJR (3 видео посмотрел)
        Плейлист очень годный нужно будет посомтреть его. Очень хорошо рассказывает.
    </div>
</div>

@section('content')
<div class="themes">
    <h1 class="themes__title">Архитектура</h1>
    <div class="theme">
        <h2 class="theme__title">
            Жизненный цикл запроса
        </h2>
        <h3 class="theme__subtitle">
            Обзор жизненного цикла
        </h3>
        <p class="theme__text">
            Точкой входа для всех запросов к приложению Laravel является файл public/index.php. Все запросы направляются в этот файл настройками вашего веб-сервера (Apache/nginx).  Файл index.php - отправная точка для загрузки остальной части фреймворка. <br>
            Файл index.php загружает автозагрузчик, который сгенерировал Composer, а затем извлекает экземпляр Laravel-приложения из скрипта bootstrap/app.php. <br><br>
            Первое действие самого Laravel - создать экземпляр приложения/сервис-контейнера.
        </p>
        <h3 class="theme__subtitle">
            Ядра HTTP/консоли
        </h3>
        <p class="theme__text">
            Затем входящий запрос отправляется либо ядру HTTP, либо ядру консоли, в зависимости от типа запроса, поступающего в приложение. Эти два ядра служат центральным местом, через которое проходят все запросы. А пока давайте сосредоточимся на ядре HTTP, которое находится в app/Http/Kernel.php. <br>
            Ядро HTTP наследует класс Illuminate\Foundation\Http\Kernel, который определяет массив загрузчиков bootstrappers, которые будут запускаться перед выполнением запроса. Эти загрузчики настраивают обработку ошибок, настраивают ведение журнала, обнаруживают среду приложения и выполняют другие задачи, которые необходимо выполнить до фактической обработки запроса. <br>
            Ядро HTTP также определяет список HTTP посредников, через которое должны пройти все запросы, прежде чем они будут обработаны приложением. Эти посредники обрабатывают чтение и запись сеанса HTTP, определяет, находится ли приложение в режиме обслуживания, проверяет токен CSRF и т. Д.<br>
            Принцип действия метода handle ядра HTTP довольно проста: получить запрос и вернуть ответ. Думайте о ядре как о большом черном ящике, который представляет все ваше приложение. Подайте ему HTTP-запросы, и он вернет HTTP-ответы.
        </p>
        <h3 class="theme__subtitle">
            Сервис-провайдеры
        </h3>
        <p class="theme__text">
            Одно из наиболее важных действий при загрузке ядра - это загрузка сервис-провайдеров для вашего приложения. Все сервис-провайдеры настраиваются в конфиге config/app.php массива providers. Сначала будет вызван метод register для всех сервис-провайдеров, а когда все они будут зарегистрированы, будет вызван метод boot. <br>
            Сервис-провайдеры отвечают за начальную загрузку всевозможных компонентов фреймворка: таких как БД, очередь, проверка ввода и маршрутизация. Сервис-провайдеры — важнейший элемент всего процесса начальной загрузки Laravel, так как они отвечают за загрузку и настройку всех возможностей фреймворка.
        </p>
        <h3 class="theme__subtitle">
            Выполнение запроса
        </h3>
        <p class="theme__text">
            Как только все сервис-провайдеры зарегистрированы и приложение загружено, Request поступает в маршрут для обработки.
            <br>
            Маршрут отправит запрос по пути, а также запустит посредника, соответствующего роуту.
            <br><br>
            Сервис-провайдеры — поистине ключ к инициализации и настройке Laravel-приложения. Создаётся экземпляр приложения, регистрируются сервис-провайдеры, и запрос передается в загруженное приложение. Всё действительно просто!<br>
    Очень важно иметь хорошее понимание того, как Laravel-приложение строится и загружается через сервис-провайдеры. Конечно, сервис-провайдеры вашего приложения по-умолчанию хранятся в директории app/Providers.<br><br>
    Основной файл, на который вам надо обратить внимание - AppServiceProvider. По умолчанию он почти пустой. Этот провайдер является отличным местом для добавления в ваше приложение собственной начальной загрузки и привязок сервис-контейнера. Конечно, в случае больших приложений, возможно вы захотите создать несколько файлов сервис-провайдеров, каждый со своей специализацией.
        </p>
    </div>
    <div class="theme">
        <h2 class="theme__title">
            Сервис-контейнер
        </h2>
        <p class="theme__text">
            Сервис-контейнер в Laravel — это мощное средство для управления зависимостями классов и внедрения зависимостей.
            <br><br>
            Внедрение зависимостей — это распространенный термин, который означает добавление других классов в этот класс через конструктор или, в некоторых случаях, метод-сеттер.
        </p>
<code>
<pre>
namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Repositories\UserRepository;
use App\Models\User;

class UserController extends Controller
{
    protected $users;

    public function __construct(UserRepository $users)
    {
        $this->users = $users;
    }

    public function show($id)
    {
        $user = $this->users->find($id);
        return view('user.profile', ['user' => $user]);
    }
}
</pre>
</code>
<p class="theme__text">
В этом примере UserController должен получить пользователей из хранилища данных. Поэтому мы будем внедрять сервис, который может получить пользователей. В данном контексте наш UserRepository скорее всего использует Eloquent для получения информации пользователя из базы данных. Однако, так как внедряется репозиторий, мы можем легко подменить его с другой реализацией. Также можно легко создать "заглушку" или фиктивную реализацию UserRepository при тестировании нашего приложения. <br><br>
Глубокое понимание сервис-контейнера Laravel важно для создания мощного, высокопроизводительного приложения, а также для работы с самим ядром Laravel.
</p>
<h3 class="theme__subtitle">
    Связывание
</h3>
<h4 class="theme_subtitlex2">
    Основы связывания
</h4>
<p class="theme__text">
    Поскольку почти все ваши привязки сервис-контейнеров будут зарегистрированы в сервис-провайдерах, то все следующие примеры демонстрируют использование контейнеров в данном контексте. <br>
    Если классы не зависят от каких-либо интерфейсов, то нет необходимости связывать их в контейнере. Не нужно объяснять контейнеру, как создавать эти объекты, поскольку он автоматически извлекает такие объекты при помощи рефлексии.
</p>
<h4 class="theme_subtitlex2">
    Простые связывания
</h4>
<p class="theme__text">
    В сервис-провайдере всегда есть доступ к контейнеру через свойство $this->app. <br> Зарегистрировать привязку можно методом bind, передав имя того класса или интерфейса, который мы хотим зарегистрировать, вместе с функцией-замыкания Closure, которая возвращает экземпляр класса:
</p>
<code>
<pre>
$this->app->bind('HelpSpot\API', function ($app) {
    return new \HelpSpot\API($app->make('HttpClient'));
});
</pre>
</code>
<p class="theme__text">
    Обратите внимание, что мы получаем сам контейнер в виде аргумента ресолвера. Затем мы можем использовать контейнер, чтобы получать под-зависимости создаваемого объекта.
</p>
<h4 class="theme_subtitlex2">
    Связывание синглтона
</h4>
<p class="theme__text">
    Метод singleton привязывает класс или интерфейс к контейнеру, который должен быть создан только один раз, и все последующие обращения к нему будут возвращать этот созданный экземпляр:
</p>
<code>
<pre>
$this->app->singleton('HelpSpot\API', function ($app) {
    return new \HelpSpot\API($app->make('HttpClient'));
});
</pre>
</code>
<h4 class="theme_subtitlex2">
    Привязка экземпляров
</h4>
<p class="theme__text">
    Вы также можете привязать существующий экземпляр объекта к контейнеру, используя метод instance. Данный экземпляр всегда будет возвращаться при последующих вызовах контейнера:
</p>
<code>
<pre>
$api = new \HelpSpot\API(new HttpClient);
$this->app->instance('HelpSpot\API', $api);
</pre>
</code>
<h4 class="theme_subtitlex2">
    Привязка интерфейсов к реализациям
</h4>
<p class="theme__text">
    Довольно мощная функция сервис-контейнера — возможность связать интерфейс с реализацией. Например, допустим у нас есть интерфейс EventPusher и реализация RedisEventPusher. И как только мы написали реализацию RedisEventPusher этого интерфейса, мы можем зарегистрировать его в сервис-контейнере следующим образом:
</p>
<code>
<pre>
$this->app->bind(
    'App\Contracts\EventPusher',
    'App\Services\RedisEventPusher'
);
</pre>
</code>
<p class="theme__text">
    Мы сообщаем контейнеру, что он должен внедрить RedisEventPusher, когда классу потребуется реализация EventPusher. Теперь мы можем указать интерфейс EventPusher в качестве аргумента метода контроллера в конструкторе, либо в любом другом месте, где сервис-контейнер внедряет зависимости:
</p>
<code>
<pre>
use App\Contracts\EventPusher;
public function __construct(EventPusher $pusher)
{
    $this->pusher = $pusher;
}
</pre>
</code>
<h4 class="theme_subtitlex2">
    Контекстная связывание
</h4>
<p class="theme__text">
    Иногда у вас может быть два класса, которые используют один и тот же интерфейс, но вы хотите внедрить разные реализации в каждый класс. Например, два контроллера могут зависеть от разных реализаций контракта Illuminate \ Contracts \ Filesystem \ Filesystem. Laravel предоставляет простой и понятный интерфейс для определения этого поведения:
</p>
<code>
<pre>
use App\Http\Controllers\PhotoController;
use App\Http\Controllers\UploadController;
use App\Http\Controllers\VideoController;
use Illuminate\Contracts\Filesystem\Filesystem;
use Illuminate\Support\Facades\Storage;

$this->app->when(PhotoController::class)
            ->needs(Filesystem::class)
            ->give(function () {
                return Storage::disk('local');
            });

$this->app->when([VideoController::class, UploadController::class])
            ->needs(Filesystem::class)
            ->give(function () {
                return Storage::disk('s3');
            });
</pre>
</code>
<h4 class="theme_subtitlex2">
    Связывание примитивов
</h4>
<p class="theme__text">
    Иногда у вас может быть класс, который получает некоторые внедренные классы, но также требует внедренного примитивного значения, такого как целое число. Вы можете легко использовать контекстную привязку, чтобы ввести любое значение, которое может понадобиться вашему классу:
</p>
<code>
<pre>
$this->app->when('App\Http\Controllers\UserController')
->needs('$variableName')
->give($value);
</pre>
</code>
<p class="theme__text">
    Иногда класс может зависеть от массива помеченных экземпляров. Используя метод giveTagged, вы можете легко внедрить все привязки контейнера с этим тегом:
</p>
<code>
<pre>
$this->app->when(ReportAggregator::class)
->needs('$reports')
->giveTagged('reports');
</pre>
</code>
<h4 class="theme_subtitlex2">
    Привязка типизированных переменных
</h4>
<p class="theme__text">
    Иногда у вас может быть класс, который получает массив типизированных объектов с использованием аргумента вариативного конструктора:
</p>
<code>
<pre>
class Firewall
{
    protected $logger;
    protected $filters;

    public function __construct(Logger $logger, Filter ...$filters)
    {
        $this->logger = $logger;
        $this->filters = $filters;
    }
}
</pre>
</code>
<p class="theme__text">
    Используя контекстную привязку, вы можете разрешить эту зависимость, предоставив методу give метод Closure, который возвращает массив разрешенных экземпляров Filter:
</p>
<code>
<pre>
$this->app->when(Firewall::class)
->needs(Filter::class)
->give(function ($app) {
        return [
            $app->make(NullFilter::class),
            $app->make(ProfanityFilter::class),
            $app->make(TooLongFilter::class),
        ];
});
</pre>
</code>
<p class="theme__text">
    Для удобства вы также можете просто предоставить массив имен классов, которые будут разрешаться контейнером всякий раз, когда Firewall требуются экземпляры Filter:
</p>
<code>
<pre>
$this->app->when(Firewall::class)
->needs(Filter::class)
->give([
    NullFilter::class,
    ProfanityFilter::class,
    TooLongFilter::class,
]);
</pre>
</code>
<h4 class="theme_subtitlex2">
    Вариативные зависимости тегов
</h4>
<p class="theme__text">
    Иногда у класса может быть вариативная зависимость, указывающая на тип как данный класс (Report ... $ reports). Используя методы need и giveTagged, вы можете легко внедрить все привязки контейнеров с этим тегом для данной зависимости:
</p>
<code>
<pre>
$this->app->when(ReportAggregator::class)
->needs(Report::class)
->giveTagged('reports');
</pre>
</code>
<h4 class="theme_subtitlex2">
    Теги
</h4>
<p class="theme__text">
    Иногда вам может потребоваться получить все реализации в определенной категории. Например, вы пишете сборщик отчётов, который принимает массив различных реализаций интерфейса Report. После регистрации реализаций Report вы можете присвоить им тег, используя метод tag:
</p>
<code>
<pre>
$this->app->bind('SpeedReport', function () {
    //
});

$this->app->bind('MemoryReport', function () {
    //
});

$this->app->tag(['SpeedReport', 'MemoryReport'], 'reports');
</pre>
</code>
<p class="theme__text">
    После того, как сервисы были помечены, вы можете легко разрешить их все с помощью метода tagged:
</p>
<code>
<pre>
$this->app->bind('ReportAggregator', function ($app) {
    return new ReportAggregator($app->tagged('reports'));
});
</pre>
</code>
<h4 class="theme_subtitlex2">
    Расширение привязок
</h4>
<p class="theme__text">
    Метод extend позволяет изменять разрешенные службы. Например, когда служба разрешена, вы можете запустить дополнительный код для украшения или настройки службы. Метод extend принимает закрытие, которое должно возвращать измененную службу в качестве единственного аргумента. Closure получает разрешаемую службу и экземпляр контейнера:
</p>
<code>
<pre>
$this->app->extend(Service::class, function ($service, $app) {
    return new DecoratedService($service);
});
</pre>
</code>
<h3 class="theme__subtitle">
    Применение на практике
</h3>
<h4 class="theme_subtitlex2">
    Метод make
</h4>
<p class="theme__text">
    Вы можете использовать метод make для извлечения экземпляра класса из контейнера. Метод make принимает имя класса или интерфейса, который вы хотите разрешить:
</p>
<code>
<pre>
    $api = $this->app->make('HelpSpot\API');
</pre>
</code>
<p class="theme__text">
    Если вы в месте своего кода, откуда нет доступа к переменной $app, то можете использовать глобальный хелпер resolve:
</p>
<code>
<pre>
    $api = resolve('HelpSpot\API');
</pre>
</code>
<p class="theme__text">
    В некоторых зависимостях вашего класса, которые нельзя получить через контейнер, можно внедрять их, передавая их в качестве ассоциативного массива в метод makeWith:
</p>
<code>
<pre>
    $api = $this->app->makeWith('HelpSpot\API', ['id' => 1]);
</pre>
</code>
<h4 class="theme_subtitlex2">
    Автоматический внедрение
</h4>
<p class="theme__text">
    В качестве альтернативы, что важно, вы можете «указать тип» зависимости в конструкторе класса, который имеется в контейнере, включая контроллеры, прослушиватели событий, промежуточное ПО и многое другое. Кроме того, вы можете указать зависимости в методе handle заданий в очереди. На практике именно так контейнер должен разрешать большинство ваших объектов.
    Например, вы можете указать тип репозитория, определённого вашим приложением в конструкторе контроллера. Репозиторий будет автоматически получен и внедрён в класс:
</p>
<code>
<pre>
namespace App\Http\Controllers;
use App\Models\Users\Repository as UserRepository;
class UserController extends Controller
{
    protected $users;
    public function __construct(UserRepository $users)
    {
        $this->users = $users;
    }
    public function show($id)
    {
        //
    }
}
</pre>
</code>
<h4 class="theme_subtitlex2">
    События контейнера
</h4>
<p class="theme__text">
    Контейнер создаёт событие каждый раз, когда из него извлекается объект. Вы можете слушать эти события, используя метод resolving:
</p>
<code>
<pre>
$this->app->resolving(function ($object, $app) {
    // Called when container resolves object of any type...
});

$this->app->resolving(\HelpSpot\API::class, function ($api, $app) {
    // Called when container resolves objects of type "HelpSpot\API"...
});
</pre>
</code>
<p class="theme__text">
    Как видите, объект, получаемый из контейнера, передаётся в функцию обратного вызова, что позволяет вам задать любые дополнительные свойства для объекта перед тем, как отдать его тому, кто его запросил.
</p>
<h3 class="theme__subtitle">
    PSR-11
</h3>
<p class="theme__text">
    Сервисный контейнер Laravel реализует интерфейс PSR-11. Поэтому вы можете ввести подсказку в интерфейсе контейнера PSR-11, чтобы получить экземпляр контейнера Laravel:
</p>
<code>
<pre>
use Psr\Container\ContainerInterface;

Route::get('/', function (ContainerInterface $container) {
    $service = $container->get('Service');

    //
});
</pre>
</code>
<p class="theme__text">
    Если данный идентификатор не может быть разрешен, создается исключение. Исключением будет экземпляр Psr \ Container \ NotFoundExceptionInterface, если идентификатор никогда не был привязан. Если идентификатор был привязан, но не удалось разрешить, будет брошен экземпляр Psr \ Container \ ContainerExceptionInterface.
</p>
    </div>
    <div class="theme">
        <h2 class="theme__title">
            Сервис-провайдеры
        </h2>
        <p class="theme__text">
            Сервис-провайдеры лежат в основе первоначальной загрузки всех приложений на Laravel. И ваше приложение, и все базовые сервисы Laravel загружаются через сервис-провайдеры.
            <br>
            Но что мы понимаем под "первоначальной загрузкой"? В общих чертах, мы имеем ввиду регистрацию таких вещей, как биндингов в IoC-контейнер (фасадов и т.д.), слушателей событий, фильтров роутов и даже самих роутов. Сервис-провайдеры - центральное место для конфигурирования вашего приложения.
             <br>
            Если вы откроете файл config/app.php, поставляемый с Laravel, то увидите массив providers. В нём перечислены все классы сервис-провайдеров, которые загружаются для вашего приложения. Конечно, многие из них являются "отложенными" провайдерами, т.е. они не загружаются при каждом запросе, а только при необходимости.
             <br>
            В этом обзоре вы узнаете, как создавать свои собственные сервис-провайдеры и регистрировать их в своём приложении.
             
        </p>
        <h3 class="theme__subtitle">
            ИСПОЛЬЗОВАНИЕ СЕРВИС-ПРОВАЙДЕРОВ
        </h3>
        <p class="theme__text">
            Все сервис-провайдеры наследуют класс Illuminate \ Support \ ServiceProvider. В большинстве сервис-провайдеров есть методы register и boot. В методе register вы должны только привязывать свои классы в сервис-контейнер. Никогда не пытайтесь зарегистрировать слушателей событий, роуты и какие-либо другие возможности в методе register.
            <br>
            С помощью Artisan CLI можно создать новый провайдер командой make:provider:
        </p>
        <code>
        <pre>
            php artisan make:provider RiakServiceProvider
        </pre>
        </code>
        <h3 class="theme__subtitle">
            Метод Register
        </h3>
        <p class="theme__text">
            Как уже было сказано, внутри метода register, вы должны только привязывать свои классы в сервис-контейнер. Никогда не пытайтесь зарегистрировать слушателей событий, роуты и какие-либо другие возможности в методе register. Иначе вы можете случайно обратиться к сервису, предоставляемому сервис-провайдером, который ещё не был загружен.
            <br>
            Давайте взглянем на простой сервис-провайдер. Из любого метода вашего сервис-провайдера у вас всегда есть доступ к свойству $app, которое предоставляет доступ к сервис-контейнеру:
        </p>
<code>
<pre>
namespace App\Providers;

use Riak\Connection;
use Illuminate\Support\ServiceProvider;

class RiakServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->singleton(Connection::class, function ($app) {
            return new Connection(config('riak'));
        });
    }
}
</pre>
</code>
        <p class="theme__text">
            Этот сервис-провайдер только определяет метод register и использует его, чтобы определить реализацию Riak \ Connection в сервис-контейнере. Если вы не понимаете как работает сервис-контейнер, прочитайте его документацию.

        </p>
        <h3 class="theme__subtitle">
            The bindings And singletons Properties
        </h3>
        <p class="theme__text">
            Если ваш поставщик услуг регистрирует много простых привязок, вы можете использовать свойства bindings и singletons вместо того, чтобы вручную регистрировать каждую привязку контейнера. Когда поставщик услуг загружается платформой, он автоматически проверяет эти свойства и регистрирует их привязки:
        </p>
<code>
<pre>
namespace App\Providers;

use App\Contracts\DowntimeNotifier;
use App\Contracts\ServerProvider;
use App\Services\DigitalOceanServerProvider;
use App\Services\PingdomDowntimeNotifier;
use App\Services\ServerToolsProvider;
use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    public $bindings = [
        ServerProvider::class => DigitalOceanServerProvider::class,
    ];

    public $singletons = [
        DowntimeNotifier::class => PingdomDowntimeNotifier::class,
        ServerProvider::class => ServerToolsProvider::class,
    ];
}
</pre>
</code>
<h3 class="theme__subtitle">
    Метод Boot
</h3>
<p class="theme__text">
    А что, если нам нужно зарегистрировать вью-композер в нашем сервис-провайдере? Это нужно делать в методе boot. Этот метод вызывают после того, как были зарегистрированы все другие сервис-провайдеры. И это значит, что у вас есть доступ ко всем другим сервисам, которые были зарегистрированы фреймворком:
</p>
<code>
<pre>
namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class ComposerServiceProvider extends ServiceProvider
{
    public function boot()
    {
        view()->composer('view', function () {
            //
        });
    }
    }
</pre>
</code>
<h4 class="theme_subtitlex2">
    Внедрение зависимостей метода Boot
</h4>
<p class="theme__text">
    Вы можете указать зависимости для метода boot вашего сервис-провайдера. Сервис-контейнер автоматически внедрит те зависимости, которые вы зададите:
</p>
<code>
<pre>
use Illuminate\Contracts\Routing\ResponseFactory;

public function boot(ResponseFactory $response)
{
    $response->macro('caps', function ($value) {
        //
    });
}
</pre>
</code>   
<h3 class="theme__subtitle">
    РЕГИСТРАЦИЯ ПРОВАЙДЕРОВ
</h3>
<p class="theme__text">
    Все сервис-провайдеры регистрируются в конфиге config / app.php . В этом файле содержится массив providers , где можно добавить имена классов ваших сервис-провайдеров. По-умолчанию в нём указан набор базовых сервис-провайдеров Laravel. Эти провайдеры загружают базовые компоненты Laravel, такие как обработчик почты, очередь, кэш и другие.
    <br><br>
    Чтобы зарегистрировать свой сервис-провайдер, просто добавьте его в этот массив:
</p>
<code>
<pre>
'providers' => [
    // Другие сервис-провайдеры

    App\Providers\ComposerServiceProvider::class,
],
</pre>
</code>
<h3 class="theme__subtitle">
    ОТЛОЖЕННЫЕ ПРОВАЙДЕРЫ
</h3>
<p class="theme__text">
    Если ваш провайдер только регистрирует привязки в сервис-контейнере, то можно отложить регистрацию до момента, когда одна из этих привязок будет запрошена из сервис-контейнера. Это позволит не тревожить файловую систему при каждом запросе, что увеличит производительность вашего приложения.
 
    Laravel компилирует и хранит список всех сервисов, предоставляемых отложенными сервис-провайдерами, и их классов. Laravel загрузит нужный сервис-провайдер только когда в процессе работы приложению понадобится один из этих сервисов.
     
    Для того, чтобы сделать сервис-провайдер отложенным, установите свойство defer равным true и определите метод providers. Метод providers должен вернуть привязки сервис-контейнера, зарегистрированные в вашем провайдере:
</p>
<code>
<pre>
    namespace App\Providers;

    use Riak\Connection;
    use Illuminate\Support\ServiceProvider;

    class RiakServiceProvider extends ServiceProvider
    {
        /**
         * Задаёт отложена ли загрузка провайдера.
         *
         * @var bool
         */
        protected $defer = true;

        /**
         * Регистрация сервис-провайдера.
         *
         * @return void
         */
        public function register()
        {
            $this->app->singleton(Connection::class, function ($app) {
                return new Connection($app['config']['riak']);
            });
        }

        /**
         * Получить предоставляемые сервисы от провайдера.
         *
         * @return array
         */
        public function provides()
        {
            return [Connection::class];
        }

    }

</pre>
</code>
    </div>
    <div class="theme">
        <h2 class="theme__title">
            Фасады
        </h2>
        <p class="theme__text">
            Фасады предоставляют "статический" интерфейс к классам, доступным в сервис-контейнере. Laravel поставляется со множеством фасадов, которые предоставляют доступ практически ко всем функциям Laravel. Фасады Laravel служат "статическими прокси" для основополагающих классов в сервис-контейнере, предоставляя преимущество лаконичного, выразительного синтаксиса, сохраняя при этом большую тестируемость и гибкость по сравнению с обычными статическими методами.
            <br><br>
            Все фасады Laravel определены в пространстве имен Illuminate \ Support \ Facades. Таким образом, мы можем легко получить доступ к фасаду:
        </p>

<code>
<pre>
use Illuminate\Support\Facades\Cache;

Route::get('/cache', function () {
    return Cache::get('key');
});
</pre>
</code>
<h3 class="theme__subtitle">
    КОГДА ИСПОЛЬЗОВАТЬ ФАСАДЫ
</h3>
<p class="theme__text">
    У фасадов множество преимуществ. Они обеспечивают лаконичный, запоминающийся синтаксис, который позволяет использовать функции Laravel без необходимости запоминать длинные названия классов, которые нужно вставить или настроить вручную. Кроме того, из-за их уникального использования динамических методов PHP, их легко тестировать.
 
    Однако при использовании фасадов необходимо проявлять определенную осторожность. Основная опасность фасадов - расширение области ответственности класса. Поскольку фасады настолько просты в использовании и не требуют внедрения, легко будет позволить вашим классам продолжать расти и использовать много фасадов в одном классе. При использовании внедрения зависимостей этот потенциал подавляется визуальной обратной связью, которую дает большой конструктор относительно того, что ваш класс становится слишком большим - т.е. однажды вы посмотрите на конструктор с множеством подключённых сторонних классов и подумаете "что-то я тут увлёкся. разобью-ка этот класс на два", а при использовании фасадов накопление сторонних зависимостей в классе проходит гораздо незаметнее. Поэтому при использовании фасадов обращайте особое внимание на размер вашего класса, чтобы его область ответственности оставалась малой, чтобы он делал одну узкоспециализированную задачу.
     
    {совет} При создании стороннего пакета, который взаимодействует с Laravel, лучше внедрять контракты Laravel вместо использования фасадов. Так как пакеты создаются вне самого Laravel, у вас не будет доступа к хелперам тестирования Laravel.
</p>
<h3 class="theme__subtitle">
    Фасады в сравнении с Внедрением зависимостей
</h3>
<p class="theme__text">
    Одним из основных преимуществ внедрения зависимостей является возможность замены реализаций внедряемого класса. Это полезно во время тестирования, так как вы можете внедрить заглушку и утверждать, что на заглушке есть различные методы.
 
    Для настоящих статических методов обычно невозможно сделать заглушку. Однако, поскольку фасады используют динамические методы для вызова метода прокси для объектов, отделенных от сервис-контейнеров, мы фактически можем тестировать фасады так же, как мы бы тестировали экземпляр внедренного класса. Например, учитывая следующий роут:
</p>
<code>
<pre>
    use Illuminate\Support\Facades\Cache;

    Route::get('/cache', function () {
        return Cache::get('key');
    });
</pre>
</code>
<p class="theme__text">
    Мы можем написать следующий тест, чтобы проверить, что метод Cache::get был вызван с ожидаемым аргументом:
</p>
<code>
<pre>
    use Illuminate\Support\Facades\Cache;

    /**
     * Пример базового функционального теста.
     *
     * @return void
     */
    public function testBasicExample()
    {
        Cache::shouldReceive('get')
             ->with('key')
             ->andReturn('value');

        $this->visit('/cache')
             ->see('value');
    }
</pre>
</code>
<h3 class="theme__subtitle">
    Фасады в сравнении с Хелперами
</h3>
<p class="theme__text">
    Помимо фасадов, Laravel включает множество вспомогательных функций, хелперов, которые могут выполнять общие задачи, такие как формирование шаблонов, запуск событий, постановка задач в очередь или отправка HTTP-ответов. Многие из этих хелперов выполняют ту же функцию, как и соответствующий фасад. Например, этот вызов фасада и этот вызов хелпера эквивалентны:
</p>
<code>
<pre>
    return View::make('profile');
    return view('profile');
</pre>
</code>
<p class="theme__text">
    Нет никакой практической разницы между фасадами и хелперами. При использовании хелперов вы можете тестировать их точно так же, как и соответствующие фасады. Например, учитывая следующий роут:
</p>
<code>
<pre>
    Route::get('/cache', function () {
        return cache('key');
    });
</pre>
</code>
<p class="theme__text">
    С точки зрения внутренней структуры, помощник cache собирается вызвать метод get в классе, основополагающем для фасада Cache . Поэтому, хотя мы используем вспомогательную функцию, мы можем написать следующий тест, чтобы убедиться, что метод был вызван с ожидаемым аргументом:
</p>
<code>
<pre>
    use Illuminate\Support\Facades\Cache;

    /**
     * Пример базового функционального теста.
     *
     * @return void
     */
    public function testBasicExample()
    {
        Cache::shouldReceive('get')
             ->with('key')
             ->andReturn('value');

        $this->visit('/cache')
             ->see('value');
    }
</pre>
</code>
<h3 class="theme__subtitle">
    КАК РАБОТАЮТ ФАСАДЫ
</h3>
<p class="theme__text">
    В контексте приложения на Laravel, фасад - это класс, который предоставляет доступ к объекту в контейнере. Весь этот механизм реализован в классе Facade. Фасады как Laravel, так и ваши собственные, наследуют этот базовый класс Illuminate \ Support \ Facades \ Facade.
 
    Класс Facade использует магический метод PHP __callStatic() для перенаправления вызовов методов с вашего фасада на полученный объект из контейнера. В примере ниже делается обращение к механизму кэширования Laravel. На первый взгляд может показаться, что статический метод get принадлежит классу Cache:
</p>
<code>
<pre>
    namespace App\Http\Controllers;

    use App\Http\Controllers\Controller;
    use Illuminate\Support\Facades\Cache;

    class UserController extends Controller
    {
        /**
         * Показать профиль для данного пользователя.
         *
         * @param  int  $id
         * @return Response
         */
        public function showProfile($id)
        {
            $user = Cache::get('user:'.$id);

            return view('profile', ['user' => $user]);
        }
    }
</pre>
</code>
<p class="theme__text">
    Обратите внимание, что в верхней части файла мы "импортируем" фасад Cache. Этот фасад служит прокси-сервером для доступа к базовой реализации интерфейса Illuminate \ Contracts \ Cache \ Factory. Любые вызовы, которые мы осуществляем с использованием фасада, будут переданы в исходный сервис кэша Laravel.
 
    Однако, если вы посмотрите в исходный код класса Illuminate \ Support \ Facades \ Cache, то увидите, что он не содержит метода get:
</p>
<code>
<pre>
    class Cache extends Facade
    {
        /**
         * Получить зарегистрированное имя компонента.
         *
         * @return string
         */
        protected static function getFacadeAccessor() { return 'cache'; }
    }
</pre>
</code>
<p class="theme__text">
    Вместо этого фасад Cache расширяется на базе класса Facade и определяет метод getFacadeAccessor(). Задача этого метода - вернуть строковое имя (ключ) привязки объекта в сервис-контейнере. Когда вы обращаетесь к любому статическому методу фасада Cache, Laravel получает объект cache из сервис-контейнера и вызывает у него требуемый метод (в этом случае - get).
</p>
<h3 class="theme__subtitle">
    Фасады в реальном времени
</h3>
<p class="theme__text">
    Используя фасады в реальном времени, вы можете рассматривать любой класс в своем приложении, как если бы он был фасадом. Чтобы проиллюстрировать, как это можно использовать, давайте рассмотрим альтернативу. Например, предположим, что наша модель Podcast имеет метод publish. Однако, чтобы опубликовать подкаст, нам нужно внедрить экземпляр Publisher:
</p>
<code>
<pre>
    namespace App\Models;

    use App\Contracts\Publisher;
    use Illuminate\Database\Eloquent\Model;

    class Podcast extends Model
    {
        /**
         * Publish the podcast.
         *
         * @param  Publisher  $publisher
         * @return void
         */
        public function publish(Publisher $publisher)
        {
            $this->update(['publishing' => now()]);

            $publisher->publish($this);
        }
    }
</pre>
</code>
<p class="theme__text">
    Внедрение реализации издателя в метод позволяет нам легко тестировать метод изолированно, поскольку мы можем имитировать внедренного издателя. Однако это требует от нас всегда передавать экземпляр издателя каждый раз, когда мы вызываем метод publish. Используя фасады в реальном времени, мы можем поддерживать такую же тестируемость, не требуя явной передачи экземпляра Publisher. Чтобы создать фасад в реальном времени, добавьте к пространству имен импортируемого класса префикс Facades:
</p>
<code>
<pre>
    namespace App\Models;

    use Facades\App\Contracts\Publisher;
    use Illuminate\Database\Eloquent\Model;

    class Podcast extends Model
    {
        /**
         * Publish the podcast.
         *
         * @return void
         */
        public function publish()
        {
            $this->update(['publishing' => now()]);

            Publisher::publish($this);
        }
    }
</pre>
</code>
<p class="theme__text">
    Когда используется фасад реального времени, реализация издателя будет разрешена из контейнера службы с использованием части интерфейса или имени класса, которая появляется после префикса Facades. При тестировании мы можем использовать встроенные помощники Laravel по тестированию фасадов, чтобы имитировать вызов этого метода:
</p>
<code>
<pre>
    namespace Tests\Feature;

    use App\Models\Podcast;
    use Facades\App\Contracts\Publisher;
    use Illuminate\Foundation\Testing\RefreshDatabase;
    use Tests\TestCase;

    class PodcastTest extends TestCase
    {
        use RefreshDatabase;

        /**
         * A test example.
         *
         * @return void
         */
        public function test_podcast_can_be_published()
        {
            $podcast = Podcast::factory()->create();

            Publisher::shouldReceive('publish')->once()->with($podcast);

            $podcast->publish();
        }
    }
</pre>
</code>
<h3 class="theme__subtitle">
    СПРАВОЧНОЕ ОПИСАНИЕ КЛАССОВ ФАСАДОВ
</h3>
<p class="theme__text">
    Ниже вы найдете каждый фасад и его основной класс. Это полезный инструмент для быстрой обработки документации API для данной корневой директории фасада. Ключ привязки сервис-контейнера также включен там, где это применимо.
    <table>
        <tr>
            <td>
                ФАСАД
            </td>
            <td>
                КЛАСС
            </td>
            <td>
                ПРИВЯЗКА СЕРВИС-КОНТЕЙНЕРА
            </td>
        </tr>
    </table>
</p>
    </div>
    <div class="theme">
        <h2 class="theme__title">
            Контракты
        </h2>
        <p class="theme__text">
            Контракты в Laravel — это набор интерфейсов, которые описывают основной функционал, предоставляемый фреймворком. Например, контракт Illuminate \ Contracts \ Queue \ Queue определяет методы, необходимые для организации очередей, в то время как контракт Illuminate \ Contracts \ Mail \ Mailer определяет методы, необходимые для отправки электронной почты.
 
            Каждый контракт имеет свою реализацию во фреймворке. Например, Laravel предоставляет реализацию Queue с различными драйверами и реализацию Mailer, использующую SwiftMailer.
             
            Все контракты Laravel живут в своих собственных репозиториях GitHub. Это ссылка на все доступные контракты, а также на один отдельный пакет, который может быть использован разработчиками пакетов.
        </p>
        <h3 class="theme__subtitle">
            Контракты или фасады?
        </h3>
        <p class="theme__text">
            Фасады Laravel и хелперы дают простой способ использования сервисов Laravel без необходимости типизирования и извлечения контрактов из сервис-контейнера. В большинстве случаев у каждого фасада есть эквивалентный контракт.
 
            В отличие от фасадов, которые не требуют того, чтобы вы запрашивали их в конструкторе вашего класса, контракты позволяют вам определить конкретные зависимости для ваших классов. Некоторые разработчики предпочитают именно так явно определять свои зависимости, поэтому предпочитают использовать контракты, а другие разработчики наслаждаются удобством фасадов.
             
            Для большинства приложений неважно, что вы выберете — фасады или контракты. Но если вы создаёте пакет, то вам надо использовать контракты, так как в этом случае их проще тестировать.
        </p>
        <h3 class="theme__subtitle">
            КОГДА ИСПОЛЬЗОВАТЬ КОНТРАКТЫ
        </h3>
        <p class="theme__text">
            Это обсуждается повсюду, и большинство дискуссий сводятся к тому, что использование контрактов или фасадов — это дело вкуса или предпочтений вашей команды разработчиков. И те, и другие можно использовать для создания надёжных, проверенных Laravel-приложений. Пока вы сохраняете границы ответственности вашего класса узкими, вы сможете заметить всего несколько практических различий между использованием контрактов и фасадов.
 
            Однако, у вас по-прежнему могут остаться некоторые вопросы о контрактах. Например, зачем вообще нужны интерфейсы? Разве использовать их не слишком сложно? Определим причины использования интерфейсов как следующие: это слабая связность и упрощение кода.
        </p>
        <h3 class="theme_subtitlex2">
            Слабая связность
        </h3>
        <p class="theme__text">
            Для начала рассмотрим код с сильной связностью с реализацией кэша:
        </p>
<code>
<pre>
namespace App\Orders;

class Repository
{
    /**
        * Экземпляр кэша.
        */
    protected $cache;

    /**
        * Создание нового экземпляра репозитория.
        *
        * @param  \SomePackage\Cache\Memcached  $cache
        * @return void
        */
    public function __construct(\SomePackage\Cache\Memcached $cache)
    {
        $this->cache = $cache;
    }

    /**
        * Получение заказа Order по ID.
        *
        * @param  int  $id
        * @return Order
        */
    public function find($id)
    {
        if ($this->cache->has($id))    {
            //
        }
    }
}
 
</pre>
</code>
<p class="theme__text">
    В этом классе код сильно связан с реализацией кэша, потому что мы зависим от конкретного класса Cache данного пакета. Если API этого пакета изменится, наш код должен также измениться.
 
    Аналогично, если мы хотим заменить нашу базовую технологию кэша (Memcached) другой технологией (Redis), нам придётся вносить изменения в наш репозиторий. А наш репозиторий не должен задумываться о том, кто именно предоставляет данные или как он это делает.
     
    Вместо такого подхода, мы можем улучшить наш код, добавив зависимость от простого интерфейса, который не зависит от поставщика:
</p>
<code>
<pre>
    namespace App\Orders;

    use Illuminate\Contracts\Cache\Repository as Cache;

    class Repository
    {
        /**
         * Экземпляр кэша.
         */
        protected $cache;

        /**
         * Создание нового экземпляра репозитория.
         *
         * @param  Cache  $cache
         * @return void
         */
        public function __construct(Cache $cache)
        {
            $this->cache = $cache;
        }
    }
</pre>
</code>
<p class="theme__text">
    Теперь код не привязан к какому-либо определённому поставщику, и даже не привязан к Laravel. Контракт не содержит никакой конкретной реализации и никаких зависимостей. Вы можете легко написать свою реализацию любого контракта, что позволяет вам заменить реализацию работы с кэшем, не изменяя ни одной строчки вашего кода, работающего с кэшем.
</p>
<h4 class="theme_subtitlex2">
    Упрощение кода
</h4>
<p class="theme__text">
    Когда все сервисы ядра фреймворка аккуратно определены в простых интерфейсах, очень легко определить, что именно делает тот или иной сервис. Фактически, контракты являются краткой документацией функций Laravel.
 
    Кроме того, когда в своём приложении вы внедряете в классы зависимости от простых интерфейсов, в вашем коде легче разобраться и его проще поддерживать. Вместо того, чтобы искать методы в большом и сложном классе, вы можете обратиться к простому и понятному интерфейсу.
</p>
<h3 class="theme__subtitle">
    КАК ИСПОЛЬЗОВАТЬ КОНТРАКТЫ
</h3>
<p class="theme__text">
    Как получить реализацию контракта? Это довольно просто.
 
    Множество типов классов в Laravel регистрируются в сервис-контейнере, включая контроллеры, слушатели событий, посредники, очереди и даже замыкания. Поэтому, чтобы получить реализацию контракта, вам достаточно указать тип интерфейса в конструкторе необходимого класса.
     
    Например, посмотрите на этот обработчик событий:
</p>
<code>
<pre>
    namespace App\Listeners;

    use App\User;
    use App\Events\OrderWasPlaced;
    use Illuminate\Contracts\Redis\Database;

    class CacheOrderInformation
    {
        /**
         * Реализация базы данных Redis.
         */
        protected $redis;

        /**
         * Создание нового экземпляра обработчика событий.
         *
         * @param  Database  $redis
         * @return void
         */
        public function __construct(Database $redis)
        {
            $this->redis = $redis;
        }

        /**
         * Обработка события.
         *
         * @param  OrderWasPlaced  $event
         * @return void
         */
        public function handle(OrderWasPlaced $event)
        {
            //
        }
    }
</pre>
</code>
<p class="theme__text">
    Когда будет получен слушатель события, сервис-контейнер прочитает указание типа в конструкторе класса и внедрит нужное значение. Узнать больше о регистрации в сервис-контейнере можно в его документации.
</p>
<h3 class="theme__subtitle">
    ТАБЛИЦА ОСНОВНЫХ КОНТРАКТОВ
</h3>
<p class="theme__text">
    В этой таблице приведены ссылки на все контракты Laravel, а также эквивалентные им фасады:
    <table>
        <tr>
            <td>
                Контракт
            </td>
            <td>
                Соответствующий фасад
            </td>
        </tr>
    </table>
</p>







    </div>



-----------------------------
<div class="themes">
    <div class="theme">
    </div>
</div>
-----------------------------
<h1 class="themes__title">

</h1>
<h2 class="theme__title">

</h2>
<h3 class="theme__subtitle">

</h3>
<h4 class="theme_subtitlex2">

</h4>
<p class="theme__text">

</p>
<code>
<pre>

</pre>
</code>







    <div class="theme">

    </div>
    <div class="theme">

    </div>
    <div class="theme">

    </div>
    <div class="theme">

    </div>
    <div class="theme">

    </div>
    <div class="theme">

    </div>
    <div class="theme">

    </div>
    <div class="theme">

    </div>
    <div class="theme">

    </div>
    <div class="theme">

    </div>
    <div class="theme">

    </div>
    <div class="theme">

    </div>
    <div class="theme">

    </div>
    <div class="theme">

    </div>
</div>



@endsection
